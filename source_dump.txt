# ==================================================
# Path: F:\colelafinal
# Detected tech: csharp
# ==================================================

## DIRECTORY STRUCTURE
```
colelafinal/
├── .git/
├── .vs/
├── Server/
│   ├── Resources/
│   │   └── UNOCards/
│   │       └── Uno.txt
│   ├── bin/
│   ├── obj/
│   ├── Program.cs
│   ├── Server.csproj
│   └── appsettings.json
├── UNO/
│   ├── .vs/
│   ├── Properties/
│   │   ├── Resources.Designer.cs
│   │   └── Resources.resx
│   ├── Resources/
│   │   ├── Cards/
│   │   │   ├── B0.png
│   │   │   ├── B1.png
│   │   │   ├── B2.png
│   │   │   ├── B3.png
│   │   │   ├── B4.png
│   │   │   ├── B5.png
│   │   │   ├── B6.png
│   │   │   ├── B7.png
│   │   │   ├── B8.png
│   │   │   ├── B9.png
│   │   │   ├── BC.png
│   │   │   ├── BD.png
│   │   │   ├── BP.png
│   │   │   ├── DD.png
│   │   │   ├── DP.png
│   │   │   ├── G0.png
│   │   │   ├── G1.png
│   │   │   ├── G2.png
│   │   │   ├── G3.png
│   │   │   ├── G4.png
│   │   │   ├── G5.png
│   │   │   ├── G6.png
│   │   │   ├── G7.png
│   │   │   ├── G8.png
│   │   │   ├── G9.png
│   │   │   ├── GC.png
│   │   │   ├── GD.png
│   │   │   ├── GP.png
│   │   │   ├── R0.png
│   │   │   ├── R1.png
│   │   │   ├── R2.png
│   │   │   ├── R3.png
│   │   │   ├── R4.png
│   │   │   ├── R5.png
│   │   │   ├── R6.png
│   │   │   ├── R7.png
│   │   │   ├── R8.png
│   │   │   ├── R9.png
│   │   │   ├── RC.png
│   │   │   ├── RD.png
│   │   │   ├── RP.png
│   │   │   ├── Y0.png
│   │   │   ├── Y1.png
│   │   │   ├── Y2.png
│   │   │   ├── Y3.png
│   │   │   ├── Y4.png
│   │   │   ├── Y5.png
│   │   │   ├── Y6.png
│   │   │   ├── Y7.png
│   │   │   ├── Y8.png
│   │   │   ├── Y9.png
│   │   │   ├── YC.png
│   │   │   ├── YD.png
│   │   │   └── YP.png
│   │   ├── 19822c18e912ad0ffb2ad2faed8a61af__1_-removebg-preview1.png
│   │   ├── Login_Screen.jpg
│   │   ├── avatar-removebg-preview.png
│   │   ├── clock-removebg-preview.png
│   │   ├── clock.png
│   │   ├── icon1-removebg-preview.png
│   │   ├── images.png
│   │   ├── light-blue-settings-gear-22453 (1).png
│   │   ├── light-blue-settings-gear-22453.png
│   │   ├── login.png
│   │   ├── login1.png
│   │   ├── menu.jpg
│   │   ├── pngtree-uno-card-png-image_9101654.png
│   │   ├── settings-glyph-black-icon-png_292947-removebg-preview.png
│   │   └── uno-card-red-poster-fahn507dk0y40lko.jpg
│   ├── bin/
│   ├── obj/
│   ├── Arena.Designer.cs
│   ├── Arena.cs
│   ├── Arena.resx
│   ├── Login.Designer.cs
│   ├── Login.cs
│   ├── Login.resx
│   ├── Menu.Designer.cs
│   ├── Menu.cs
│   ├── Menu.resx
│   ├── Program.cs
│   ├── UNO.csproj
│   ├── UNO.csproj.user
│   └── UNO.sln
├── .gitignore
├── README.md
└── source_dump.txt
```

## FILE CONTENTS

### Server\Program.cs
```cs
﻿using BCrypt.Net; // Add this using directive for BCrypt
using FirebaseAdmin;
using FirebaseAdmin.Auth;
using Google.Apis.Auth.OAuth2;
using Google.Cloud.Firestore;
using Google.Cloud.Firestore.V1;
using Microsoft.Data.SqlClient;
using Microsoft.Extensions.Configuration;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Text;
using static System.Net.Mime.MediaTypeNames;

// Ensure you have added the BCrypt.Net-Next NuGet package to your project.

Server server = new Server();
server.StartServer();
Console.WriteLine("Server is running!");

public class Server
{
    //khởi tạo các biến cần thiết cho server
    private readonly string _connStr;
    private readonly FirestoreDb db;
    private Thread serverThread;
    private Socket serverSocket;
    private bool isRunning = false;
    private int byteRecv = 0;
    private byte[] buffer = new byte[1024];
    private readonly ConcurrentDictionary<Socket, (string Uid, string Username)> authenticatedPlayers = new ConcurrentDictionary<Socket, (string, string)>();
    // Track client threads and cancellation tokens for proper cleanup
    private readonly ConcurrentDictionary<Socket, (Thread Thread, CancellationTokenSource CancellationTokenSource)> clientThreads = new ConcurrentDictionary<Socket, (Thread, CancellationTokenSource)>();
    //lưu trữ danh sách phòng để chứa người chơi
    List<Room> roomList = new List<Room>();
    private void RefillDrawPile(Room room)
    {
        if (room.Dataqueue1.Count <= 1) return;  // only keep top
        var top = room.Dataqueue1.Dequeue();
        // move rest to draw pile
        while (room.Dataqueue1.Count > 0)
            room.Dataqueue.Enqueue(room.Dataqueue1.Dequeue());
        ShuffleQueue(room.Dataqueue);
        room.Dataqueue1.Enqueue(top);
        // broadcast new top
        SenUnoCardTop(room, "");
    }
    /// <summary>
    /// Hoán vị ngẫu nhiên các phần tử trong queue.
    /// </summary>
    private void ShuffleQueue<T>(Queue<T> queue)
    {
        // Chuyển queue thành list để dễ hoán vị
        var list = queue.ToList();
        queue.Clear();  // Xóa hết phần tử cũ

        var rnd = new Random();
        // Lấy ngẫu nhiên từng phần tử từ list rồi enqueue trở lại
        while (list.Count > 0)
        {
            int idx = rnd.Next(list.Count);
            queue.Enqueue(list[idx]);
            list.RemoveAt(idx);
        }
    }
    private void SenUnoCardTop(Room room, string unused)
    {
        if (room.Dataqueue1.Count == 0) return;
        var top = room.Dataqueue1.Peek();
        Console.WriteLine($"[DEBUG][CardTop] Card: {top}, Màu hiện tại: {room.pendingWildColor}");
        foreach (var sock in room.ClientId.Keys)
            sock.Send(Encoding.UTF8.GetBytes($"CardTop: {top}|{room.pendingWildColor}\n"));
    }

    public Server()
    {
        string serviceAccountFileName = "gameuno-4db86-firebase-adminsdk-fbsvc-e9eb161dd1.json";
        string currentDirectory = Directory.GetCurrentDirectory(); // Lấy thư mục hiện hành của ứng dụng
        string serviceAccountPath = Path.Combine(currentDirectory, serviceAccountFileName);
        // Kiểm tra xem tệp có tồn tại không
        if (!File.Exists(serviceAccountPath))
        {
            Console.WriteLine($"Lỗi: Không tìm thấy tệp khóa dịch vụ Firebase: {serviceAccountPath}");
            Console.WriteLine("Vui lòng tải xuống tệp .json từ Firebase Console (Project settings -> Service accounts -> Generate new private key) và đặt vào cùng thư mục với ứng dụng server của bạn.");
            return; // Dừng khởi tạo nếu không tìm thấy tệp
        }

        try
        {
            GoogleCredential credential = GoogleCredential.FromFile(serviceAccountPath);

            // FirebaseApp.Create(new AppOptions() // No longer strictly needed for just Firestore, but good to keep if you might use other Firebase services.
            // {
            //     Credential = credential,
            // });

            db = new FirestoreDbBuilder
            {
                ProjectId = "gameuno-4db86", // Thay bằng ID dự án của bạn
                Credential = credential // RẤT QUAN TRỌNG: Truyền credential trực tiếp ở đây
            }.Build();

            Console.WriteLine("Firebase Firestore khởi tạo thành công!");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Lỗi nghiêm trọng khi kết nối Firebase hoặc khởi tạo Firestore: {ex.Message}");
            Console.WriteLine($"Chi tiết: {ex.StackTrace}");
        }
    }
    public async void TestFirestoreConnection()
    {
        if (db == null)
        {
            Console.WriteLine("Firestore database is not initialized.");
            return;
        }

        try
        {
            // Tạo một collection tạm thời và thêm một document
            CollectionReference testCollection = db.Collection("test_connections");
            DocumentReference testDoc = testCollection.Document("server_status");

            // Cập nhật hoặc tạo document với timestamp
            await testDoc.SetAsync(new { last_connected = FieldValue.ServerTimestamp, status = "online" });

            // Đọc lại document để xác nhận
            DocumentSnapshot snapshot = await testDoc.GetSnapshotAsync();
            if (snapshot.Exists)
            {
                Console.WriteLine("Kiểm tra kết nối Firebase Firestore thành công!");
                Console.WriteLine($"Trạng thái server cuối cùng kết nối: {snapshot.GetValue<Timestamp>("last_connected").ToDateTime()}");
            }
            else
            {
                Console.WriteLine("Kiểm tra kết nối Firebase Firestore thất bại: Không thể đọc lại document.");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Lỗi khi kiểm tra kết nối Firebase Firestore: {ex.Message}");
            Console.WriteLine($"Chi tiết: {ex.StackTrace}");
        }
    }
    //private void SendInitialQueues(Room room)
    //{
    //    // saves dataqueue and dataqueue1 as strings
    //    string drawPile = string.Join(",", room.Dataqueue);
    //    string discardPile = string.Join(",", room.Dataqueue1);

    //    //wraps them inside a message to send to the clients
    //    string message = $"Dataqueue: {drawPile}|{discardPile}\n";
    //    Console.WriteLine(message.Length);
    //    foreach (var sock in room.ClientId.Keys)
    //    {
    //        try
    //        {
    //            byte[] data = Encoding.UTF8.GetBytes(message);
    //            Console.WriteLine(message.Length);
    //            sock.Send(data, 0, data.Length, SocketFlags.None);
    //        }
    //        catch (SocketException ex)
    //        {
    //            Console.WriteLine($"Error sending queues to client: {ex.Message}");
    //        }
    //    }
    //}

    //as what the function says, when the room is first initialized, we send the clients the first cards
    private void SendInitialHand(Room room)
    {
        try
        {
            if (room.Dataqueue.Count > 0)
            {
                string topCard;
                do
                {
                    topCard = room.Dataqueue.Dequeue();
                    if (topCard == "DD" || topCard == "DP") room.Dataqueue.Enqueue(topCard);
                } while (topCard == "DD" || topCard == "DP");
                room.Dataqueue1.Enqueue(topCard);
                room.currentValue = topCard.Substring(1);
                room.pendingWildColor = topCard[0];
            }

            foreach (var sock in room.ClientId.Keys)
            {
                int playerId = room.ClientId[sock];
                // Lấy 6 lá bài đầu
                var queue = new ConcurrentQueue<string>();
                for (int i = 0; i < 6; i++)
                {
                    string card = room.Dataqueue.Dequeue();
                    queue.Enqueue(card);
                }
                // Gán queue mới vào playerHands
                room.playerHands[playerId] = queue;

                // Gửi danh sách bài cho client (giữ thứ tự)
                string handMsg = "InitialHand: " + string.Join(",", queue) + "\n";
                sock.Send(Encoding.UTF8.GetBytes(handMsg));
            }
            SenUnoCardTop(room, "");
            Broadcast(room, $"PendingDraw: 0\n");

        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
        }
    }
    private bool HasPlayableCards(Room room, int playerId)
    {
        if (!room.playerHands.ContainsKey(playerId)) return false;
        foreach (string card in room.playerHands[playerId])
        {
            if (IsPlayable(card, room))
                return true;
        }
        return false;
    }
    private bool HasCounterCard(Room room, int playerId)
    {
        // Nếu không có tay bài, trả false
        if (!room.playerHands.TryGetValue(playerId, out var queue))
            return false;

        // Lấy lá trên cùng của discard pile
        if (room.Dataqueue1.Count == 0)
            return false;
        string topCard = room.Dataqueue1.Last();

        // Nếu top là +4, chỉ cho chồng +4
        if (topCard == "DP")
        {
            // Dùng Any để check trong snapshot
            return queue.Any(c => c == "DP");
        }
        // Nếu top là +2 (endswith 'P' nhưng != DP), cho chồng +2 hoặc +4
        else if (topCard.EndsWith("P"))
        {
            return queue.Any(c => c.EndsWith("P"));
        }

        // Không phải +2/+4 => không áp dụng chồng
        return false;
    }


    private async void HandleClient(Socket acceptedClient, CancellationToken cancellationToken)
    {
        Console.WriteLine($"[DEBUG] Client thread started for socket {acceptedClient.Handle}");
        
        int currentPlayerId = 0;
        Room rooms = null;
        string username = "";
        string authenticatedUserUid = null; // Changed from FirebaseUid as we're not using Firebase Auth UIDs directly.
                                            // We'll use the username as the document ID for players.

        if (authenticatedPlayers.TryGetValue(acceptedClient, out var playerInfo))
        {
            authenticatedUserUid = playerInfo.Uid; // This will now be the username as the doc ID
            username = playerInfo.Username;
        }

        while (acceptedClient.Connected && !cancellationToken.IsCancellationRequested)
        {
            try
            {
                // Check for cancellation before receiving data
                if (cancellationToken.IsCancellationRequested)
                {
                    Console.WriteLine($"[DEBUG] Cancellation requested for client thread");
                    break;
                }
                
                byteRecv = acceptedClient.Receive(buffer);
                if (byteRecv == 0)
                {
                    break;
                }

                string message = Encoding.UTF8.GetString(buffer, 0, byteRecv);

                if (message == null) break;

                //xử lí yêu cầu đăng nhập của người chơi
                if (message.StartsWith("Player: "))
                {
                    try
                    {
                        string[] parts = message.Substring("Player: ".Length).Split('|');
                        if (parts.Length != 2)
                        {
                            acceptedClient.Send(Encoding.UTF8.GetBytes("LoginFail: InvalidFormat\n"));
                            continue; // Use continue to keep the client connected for other messages
                        }

                        string userAttemptedUsername = parts[0].Trim();
                        string userAttemptedPassword = parts[1].Trim();

                        if (string.IsNullOrEmpty(userAttemptedUsername) || string.IsNullOrEmpty(userAttemptedPassword))
                        {
                            acceptedClient.Send(Encoding.UTF8.GetBytes("LoginFail: MissingCredentials\n"));
                            continue;
                        }

                        DocumentReference userDocRef = db.Collection("players").Document(userAttemptedUsername);
                        DocumentSnapshot snapshot = await userDocRef.GetSnapshotAsync();

                        if (snapshot.Exists)
                        {
                            // User exists, check status and password
                            long status = snapshot.GetValue<long>("status");
                            string storedHashedPassword = snapshot.GetValue<string>("passwordHash");
                            string storedUsername = snapshot.GetValue<string>("username"); // Get username from Firestore

                            if (status == 1)
                            {
                                // User is already online
                                Console.WriteLine($"LoginFail for {userAttemptedUsername}: AlreadyOnline.");
                                acceptedClient.Send(Encoding.UTF8.GetBytes("LoginFail: AlreadyOnline\n"));
                                continue;
                            }
                            else if (status == 0)
                            {
                                // User is offline, check password
                                if (BCrypt.Net.BCrypt.Verify(userAttemptedPassword, storedHashedPassword))
                                {
                                    // Password matches, log in
                                    var updates = new Dictionary<string, object>
                                    {
                                        { "status", 1 },
                                        { "lastLogin", FieldValue.ServerTimestamp }
                                    };
                                    await userDocRef.UpdateAsync(updates);
                                    authenticatedPlayers.TryAdd(acceptedClient, (userAttemptedUsername, storedUsername));
                                    authenticatedUserUid = userAttemptedUsername;
                                    username = storedUsername;
                                    Console.WriteLine($"Successfully logged in {userAttemptedUsername}. Status updated to online.");
                                    acceptedClient.Send(Encoding.UTF8.GetBytes($"LoginOK: {userAttemptedUsername}\n"));
                                }
                                else
                                {
                                    // Incorrect password
                                    Console.WriteLine($"LoginFail for {userAttemptedUsername}: WrongPassword.");
                                    acceptedClient.Send(Encoding.UTF8.GetBytes("LoginFail: WrongPassword\n"));
                                    continue;
                                }
                            }
                        }
                        else
                        {
                            // User does not exist, create new account (registration)
                            Console.WriteLine($"User {userAttemptedUsername} not found. Creating new account.");
                            try
                            {
                                string hashedPassword = BCrypt.Net.BCrypt.HashPassword(userAttemptedPassword);

                                var newUserData = new Dictionary<string, object>
                                {
                                    { "username", userAttemptedUsername }, // Using the attempted username as display name and document ID
                                    { "passwordHash", hashedPassword },
                                    { "status", 1 }, // Set status to online upon creation
                                    { "lastLogin", FieldValue.ServerTimestamp },
                                    { "createdAt", FieldValue.ServerTimestamp }
                                };

                                await userDocRef.SetAsync(newUserData);
                                authenticatedPlayers.TryAdd(acceptedClient, (userAttemptedUsername, userAttemptedUsername));
                                authenticatedUserUid = userAttemptedUsername;
                                username = userAttemptedUsername;
                                Console.WriteLine($"Successfully created and logged in new user: {userAttemptedUsername}");
                                acceptedClient.Send(Encoding.UTF8.GetBytes($"LoginOK: {userAttemptedUsername}\n"));
                            }
                            catch (Exception createEx)
                            {
                                Console.WriteLine($"Error creating user {userAttemptedUsername} in Firestore: {createEx.Message}");
                                acceptedClient.Send(Encoding.UTF8.GetBytes($"LoginFail: RegistrationFailed|{createEx.Message}\n"));
                                continue;
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"General error in Player message handling: {ex.Message}");
                        acceptedClient.Send(Encoding.UTF8.GetBytes($"LoginFail: InternalServerError\n"));
                        continue;
                    }
                }

                //xử lí yêu cầu vào phòng chơi của người chơi
                else if (message.StartsWith("Play now: "))
                {
                    username = message.Substring(10).Trim();

                    //chủ yếu kiểm tra xem người dùng đã vào được phòng hay chưa
                    string checkRoomInfo = string.Empty;

                    //nó tương tự như này: for (int i = 0; i < roomList.Count; i++)
                    foreach (Room room in roomList)
                    {
                        //tìm thấy phòng trống thông tin người chơi đầu
                        if (room.player[1].Item1 == string.Empty)
                        {
                            room.player[1] = (username, acceptedClient);
                            room.ClientId[acceptedClient] = 1;
                            checkRoomInfo = $"Player {username} has joined in room {room.id}";
                            Console.WriteLine(checkRoomInfo);

                            //cuối cùng, gửi id phòng đến người chơi để client có thể tiến hành thay đổi
                            string sendPlayRequest = $"Room: {room.id}";
                            byte[] sendClient = Encoding.UTF8.GetBytes(sendPlayRequest);
                            acceptedClient.Send(sendClient);
                            string status = $"{room.countrd[1]},{room.countrd[2]},{room.countrd[3]},{room.countrd[4]}";
                            byte[] init = Encoding.UTF8.GetBytes($"isPlay: {status}\n");
                            acceptedClient.Send(init, 0, init.Length, SocketFlags.None);
                            string sendIdMessage = $"YourId: 1\n"; // Gửi ID cho player 1
                            acceptedClient.Send(Encoding.UTF8.GetBytes(sendIdMessage));
                            break;

                        }
                        //tìm thấy phòng trống thông tin người chơi thứ hai
                        else if (room.player[2].Item1 == string.Empty)
                        {
                            room.player[2] = (username, acceptedClient);
                            room.ClientId[acceptedClient] = 2;
                            checkRoomInfo = $"Player {username} has joined in room {room.id}";
                            Console.WriteLine(checkRoomInfo);

                            //cuối cùng, gửi id phòng đến người chơi để client có thể tiến hành thay đổi
                            string sendPlayRequest = $"Room: {room.id}";
                            byte[] sendClient = Encoding.UTF8.GetBytes(sendPlayRequest);
                            acceptedClient.Send(sendClient);
                            string status = $"{room.countrd[1]},{room.countrd[2]},{room.countrd[3]},{room.countrd[4]}";
                            byte[] init = Encoding.UTF8.GetBytes($"isPlay: {status}\n");
                            acceptedClient.Send(init, 0, init.Length, SocketFlags.None);
                            string sendIdMessage = $"YourId: 2\n"; // Gửi ID cho player 2
                            acceptedClient.Send(Encoding.UTF8.GetBytes(sendIdMessage));
                            break;
                        }
                        else if (room.player[3].Item1 == string.Empty)
                        {
                            room.player[3] = (username, acceptedClient);
                            room.ClientId[acceptedClient] = 3;
                            checkRoomInfo = $"Player {username} has joined in room {room.id}";
                            Console.WriteLine(checkRoomInfo);

                            //cuối cùng, gửi id phòng đến người chơi để client có thể tiến hành thay đổi
                            string sendPlayRequest = $"Room: {room.id}";
                            byte[] sendClient = Encoding.UTF8.GetBytes(sendPlayRequest);
                            acceptedClient.Send(sendClient);
                            string status = $"{room.countrd[1]},{room.countrd[2]},{room.countrd[3]},{room.countrd[4]}";
                            byte[] init = Encoding.UTF8.GetBytes($"isPlay: {status}\n");
                            acceptedClient.Send(init, 0, init.Length, SocketFlags.None);
                            string sendIdMessage = $"YourId: 3\n"; // Gửi ID cho player 3
                            acceptedClient.Send(Encoding.UTF8.GetBytes(sendIdMessage));
                            break;
                        }
                        else if (room.player[4].Item1 == string.Empty)
                        {
                            room.player[4] = (username, acceptedClient);
                            room.ClientId[acceptedClient] = 4;
                            checkRoomInfo = $"Player {username} has joined in room {room.id}";
                            Console.WriteLine(checkRoomInfo);

                            //cuối cùng, gửi id phòng đến người chơi để client có thể tiến hành thay đổi
                            string sendPlayRequest = $"Room: {room.id}";
                            byte[] sendClient = Encoding.UTF8.GetBytes(sendPlayRequest);
                            acceptedClient.Send(sendClient);
                            string status = $"{room.countrd[1]},{room.countrd[2]},{room.countrd[3]},{room.countrd[4]}";
                            byte[] init = Encoding.UTF8.GetBytes($"isPlay: {status}\n");
                            acceptedClient.Send(init, 0, init.Length, SocketFlags.None);
                            string sendIdMessage = $"YourId: 4\n"; // Gửi ID cho player 4
                            acceptedClient.Send(Encoding.UTF8.GetBytes(sendIdMessage));
                            break;
                        }
                    }
                    //nếu chưa tìm thấy phòng, tạo phòng mới cho người chơi
                    if (checkRoomInfo.Length <= 0)
                    {
                        int roomCount = FindNextAvailableRoomId(); //id phòng mới
                        Room newRoom = new Room(roomCount);
                        newRoom.player[1] = (username, acceptedClient);
                        newRoom.ClientId[acceptedClient] = 1;
                        string sendIdMessage = $"YourId: {newRoom.ClientId[acceptedClient]}\n";
                        byte[] idData = Encoding.UTF8.GetBytes(sendIdMessage);
                        acceptedClient.Send(idData);
                        roomList.Add(newRoom);
                        checkRoomInfo = $"Player {username} has joined in room {newRoom.id}";
                        Console.WriteLine(checkRoomInfo);

                        //cuối cùng, gửi id phòng đến người chơi để client có thể tiến hành thay đổi
                        string sendPlayRequest = $"Room: {newRoom.id}";
                        byte[] sendClient = Encoding.UTF8.GetBytes(sendPlayRequest);
                        acceptedClient.Send(sendClient);
                    }
                }
                // xử lý khi người chơi nhấn ready;
                else if (message.StartsWith("Ready:"))
                {
                    Room room = FindRoombyClientID(acceptedClient);
                    if (room != null)
                    {
                        int ID = room.ClientId[acceptedClient];
                        room.countrd[ID] = 1;
                        Console.WriteLine(room.countrd[ID]);
                        room.sumcountrd = room.countrd[1] + room.countrd[2] + room.countrd[3] + room.countrd[4];
                        Console.WriteLine($"Player {username} has ready in room {room.id}");
                        string status = $"{room.countrd[1]},{room.countrd[2]},{room.countrd[3]},{room.countrd[4]}";
                        string messageToClients = $"isPlay: {status}\n";
                        Console.WriteLine(messageToClients);
                        byte[] data = Encoding.UTF8.GetBytes(messageToClients);
                        foreach (var sock in room.ClientId.Keys)
                        {
                            sock.Send(data, 0, data.Length, SocketFlags.None);
                        }

                        if (room.rommbg == 0 && room.sumcountrd == 4)
                        {
                            Console.WriteLine($"[DEBUG] Starting new game in room {room.id}. rommbg={room.rommbg}, sumcountrd={room.sumcountrd}");
                            room.rommbg = 1;
                            foreach (var sock in room.ClientId.Keys)
                            {
                                int id = room.ClientId[sock];
                                sock.Send(Encoding.UTF8.GetBytes($"YourId: {id}\n"));
                            }

                            Broadcast(room, $"Turn: {room.currentTurn}\n");
                            Broadcast(room, $"PendingDraw: {room.pendingDrawCards}\n");
                            SenUnoCardTop(room, "");
                            // Tạo chuỗi tên, giữ đúng thứ tự 1→4
                            string namesMsg = $"PlayerNames: {room.player[1].Item1}|{room.player[2].Item1}|{room.player[3].Item1}|{room.player[4].Item1}\n";
                            Broadcast(room, namesMsg);

                            SendInitialHand(room);
                        }
                    }
                    Console.WriteLine("ready");
                }
                else if (message.StartsWith("PlayCard: "))
                {
                    Console.WriteLine($"[DEBUG] Sending message: {message}");
                    Console.WriteLine($"[DEBUG] Received raw PlayCard message: '{message.Trim()}'");
                    Room room = FindRoombyClientID(acceptedClient);
                    int playerId = room.ClientId[acceptedClient];
                    var parts = message.Substring(10).Split('|');
                    string cardRaw = parts[0].Trim().Split('|')[0];
                    string card = cardRaw;
                    Console.WriteLine($"[DEBUG] [PlayCard] Nhận từ player{playerId}: {message.Trim()}");
                    char color = parts.Length > 1 ? parts[1][0] : room.pendingWildColor;
                    // enqueue discard
                    room.Dataqueue1.Enqueue(card);
                    // update wild color & currentValue
                    room.pendingWildColor = (card == "DD" || card == "DP") ? color : card[0];
                    room.currentValue = (card == "DD" || card == "DP") ? card : card.Substring(1);

                    // process +2/+4
                    if (card == "DP")
                    {
                        // Nếu đang có pendingDrawCards (>0), dù là do +2 hay +4, DP sẽ chồng tiếp 4 lá
                        if (room.pendingDrawCards > 0)
                            room.pendingDrawCards += 4;
                        else
                            room.pendingDrawCards = 4;
                    }
                    else if (card.EndsWith("P"))
                    {
                        if (room.pendingDrawCards > 0)
                            room.pendingDrawCards += 2;
                        else if (room.pendingDrawCards == 0)
                            room.pendingDrawCards = 2;
                    }
                    else
                    {
                        room.pendingDrawCards = 0;
                    }


                    // xu li la dao nguoc 
                    if (card == "RD" || card == "GD" || card == "BD" || card == "YD")
                    {
                        room.isReversed = !room.isReversed;
                        Console.WriteLine($"[DEBUG] Reverse status: {room.isReversed}");
                    }
                    int next = nextplayer(playerId, room.isReversed);
                    // xử lý khi gặp lá skip
                    if (card.EndsWith("C"))
                    {
                        next = nextplayer(next, room.isReversed);
                    }
                    room.currentTurn = next;
                    // send new top, turn, pending draw
                    Console.WriteLine($"[DEBUG][PlayCard] - Giá trị hiện tại: {room.currentValue}");
                    Console.WriteLine($"[DEBUG][PlayCard] - Lượt tiếp theo: {room.currentTurn}");
                    Console.WriteLine($"[DEBUG][PlayCard] - Màu hiện tại: {room.pendingWildColor}");
                    Console.WriteLine($"[DEBUG][PlayCard] - Số card pen : {room.pendingDrawCards}");
                    Console.WriteLine($"[DEBUG] card nhận được: {card}");


                    Broadcast(room, $"CardTop: {card}|{room.pendingWildColor}\n");
                    Broadcast(room, $"Turn: {room.currentTurn}\n");
                    Broadcast(room, $"PendingDraw: {room.pendingDrawCards}\n");

                    if (room.playerHands.TryGetValue(playerId, out var queue))
                    {
                        // Tạo danh sách tạm để chứa các lá bài không phải lá vừa đánh
                        var temp = new List<string>();
                        bool removed = false;

                        // Lấy từng lá từ queue gốc, bỏ lá đã đánh, và lưu lại những lá còn lại
                        while (queue.TryDequeue(out var c))
                        {
                            if (!removed && (c == card ||
                        (card == "DD" && c.StartsWith("DD")) ||
                        (card == "DP" && c.StartsWith("DP"))))
                            {
                                removed = true;
                                continue; // Bỏ qua lá đã đánh
                            }
                            temp.Add(c);
                        }

                        // Thêm lại các lá còn lại vào queue (giữ thứ tự)
                        foreach (var c in temp)
                            queue.Enqueue(c);
                    }

                    int remaining = room.playerHands[playerId].Count;
                    Broadcast(room, $"Remaining: {playerId}:{remaining}\n");

                    // Nếu người chơi còn 1 lá và chưa gọi UNO trước đó
                    if (remaining == 1 && !room.UnoCalled[playerId])
                    {
                        room.CatchOccurred = false;
                        string catchMsg = $"CatchWindow: {playerId}\n";
                        byte[] data = Encoding.UTF8.GetBytes(catchMsg);

                        Console.WriteLine($"[DEBUG] Gửi CatchWindow cho các người chơi khác (loại trừ player {playerId})");
                        foreach (var sock in room.ClientId.Keys)
                        {
                            int receiverId = room.ClientId[sock];
                            if (receiverId != playerId)
                            {
                                Console.WriteLine($"[DEBUG] Gửi CatchWindow đến player {receiverId}");
                                sock.Send(data);
                            }
                        }
                        Console.WriteLine($"[DEBUG] CatchWindow message đã gửi.");
                    }
                    else Console.WriteLine($"[DEBUG] Không gửi CatchWindow: playerId={playerId}, remaining={remaining}, UnoCalled={room.UnoCalled[playerId]}");


                    // Nếu người chơi đã đánh hết bài
                    if (remaining == 0)
                    {
                        // Xác định người thắng và thông báo cho tất cả client
                        string winner = room.player[playerId].Item1;
                        DeleteRoom(room);
                        Broadcast(room, $"PlayerWin: {winner}\n");
                    }

                    // Sau khi Broadcast Turn và PendingDraw

                    if (room.pendingDrawCards > 0)
                    {
                        int nextId = room.currentTurn;
                        // Nếu người chơi kế tiếp không có lá +2/+4 phù hợp thì tự động rút bài
                        if (!HasCounterCard(room, nextId))
                        {
                            var nextSock = room.player[nextId].Item2;
                            Console.WriteLine($"[DEBUG] next={nextId}, hasCounter={HasCounterCard(room, nextId)}, pending={room.pendingDrawCards}");

                            string notify = $"AutoDrawCount: {room.pendingDrawCards}\n";
                            nextSock.Send(Encoding.UTF8.GetBytes(notify));
                            for (int i = 0; i < room.pendingDrawCards; i++)
                            {
                                if (room.Dataqueue.Count == 0) RefillDrawPile(room);
                                string newCard = room.Dataqueue.Dequeue();
                                room.playerHands[nextId].Enqueue(newCard);

                                Socket sock = room.player[nextId].Item2;
                                sock.Send(Encoding.UTF8.GetBytes($"DrawCard: {newCard}\n"));
                                Task.Delay(200).Wait();
                            }
                            // Reset lại PendingDraw về 0 và thông báo cho tất cả client
                            room.pendingDrawCards = 0;
                            Broadcast(room, $"PendingDraw: 0\n");
                        }
                    }

                }
                else if (message.StartsWith("DrawCard"))
                {
                    var room = FindRoombyClientID(acceptedClient);
                    if (room.pendingDrawCards > 0)
                    {
                        continue;
                    }
                    {
                        int playerId = room.ClientId[acceptedClient];


                        if (room.Dataqueue.Count == 0) RefillDrawPile(room);

                        var drawnCard = room.Dataqueue.Dequeue();
                        room.playerHands[playerId].Enqueue(drawnCard);

                        acceptedClient.Send(Encoding.UTF8.GetBytes($"DrawCard: {drawnCard}\n"));
                    }


                    // broadcast new top
                }
                else if (message.StartsWith("UnoCall: "))
                {
                    Room room = FindRoombyClientID(acceptedClient);
                    int playerId = room.ClientId[acceptedClient];
                    room.UnoCalled[playerId] = true;
                    Console.WriteLine($"[DEBUG] Player {playerId} gọi UNO.");
                    continue;
                }
                else if (message.StartsWith("CatchUno: "))
                {
                    Room room = FindRoombyClientID(acceptedClient);
                    int catcher = room.ClientId[acceptedClient];
                    int targetId = int.Parse(message.Substring("CatchUno: ".Length).Trim());
                    // Nếu mục tiêu chưa gọi UNO và chưa ai bắt được:
                    if (!room.UnoCalled[targetId] && !room.CatchOccurred)
                    {
                        room.CatchOccurred = true;
                        // Phạt target rút thêm 2 lá
                        for (int i = 0; i < 2; i++)
                        {
                            if (room.Dataqueue.Count == 0) RefillDrawPile(room);
                            string newCard = room.Dataqueue.Dequeue();
                            room.playerHands[targetId].Enqueue(newCard);

                            var targetSocket = room.player[targetId].Item2;
                            targetSocket.Send(Encoding.UTF8.GetBytes($"DrawCard: {newCard}\n"));
                        }
                        Broadcast(room, "HideCatchWindow:\n");
                    }
                    Console.WriteLine($"[DEBUG] Player {catcher} bắt lỗi player {targetId}");
                    continue;

                }
                else if (message.StartsWith("Chat: "))
                {
                    Room room = FindRoombyClientID(acceptedClient);
                    int playerId = room.ClientId[acceptedClient];
                    string msgContent = message.Substring(6).Trim();
                    string playerName = room.player[playerId].Item1;

                    string pendingMessage = $"Chat: {playerName}|{msgContent}\n";
                    Broadcast(room, pendingMessage);
                }
                else if (message.StartsWith("Disconnect: "))
                {
                    await HandleClientDisconnection(acceptedClient, username, authenticatedUserUid);
                    return; // Exit the loop since client is disconnecting
                }

            }
            catch (Exception ex)
            {
                // Check if this is a cancellation exception
                if (cancellationToken.IsCancellationRequested)
                {
                    Console.WriteLine($"[DEBUG] Thread cancelled, exiting gracefully");
                    break;
                }
                
                Console.WriteLine($"[ERROR] Client connection error: {ex.Message}");
                // Handle unexpected disconnection
                await HandleClientDisconnection(acceptedClient, username, authenticatedUserUid);
            }
        }
        
        // Final cleanup when client thread ends
        Console.WriteLine($"[DEBUG] Client thread ending for {username}");
        
        // Clean up thread tracking if not already done
        if (clientThreads.TryRemove(acceptedClient, out var threadInfo))
        {
            Console.WriteLine($"[DEBUG] Removed client thread tracking for {username}");
            // Dispose the cancellation token source
            threadInfo.CancellationTokenSource.Dispose();
        }
    }



    private void Broadcast(Room room, string msg)
    {
        var data = Encoding.UTF8.GetBytes(msg);
        foreach (var sock in room.ClientId.Keys)
            sock.Send(data);
    }

    private void DeleteRoom(Room oldRoom)
    {
        Console.WriteLine($"[DEBUG] Deleting room {oldRoom.id} after game completion");
        
        try
        {
            // Simply remove the old room from the room list
            roomList.Remove(oldRoom);
            
            Console.WriteLine($"[DEBUG] Room {oldRoom.id} has been deleted successfully");
            Console.WriteLine($"[DEBUG] Remaining rooms: {roomList.Count}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[ERROR] Failed to delete room {oldRoom.id}: {ex.Message}");
            Console.WriteLine($"[ERROR] Stack trace: {ex.StackTrace}");
        }
    }

    private int FindNextAvailableRoomId()
    {
        // Find the lowest available room ID
        int nextId = 0;
        while (roomList.Any(room => room.id == nextId))
        {
            nextId++;
        }
        
        Console.WriteLine($"[DEBUG] Next available room ID: {nextId}");
        return nextId;
    }

    private async Task HandleClientDisconnection(Socket clientSocket, string username, string authenticatedUserUid)
    {
        Console.WriteLine($"[DEBUG] Handling disconnection for {username}");
        
        try
        {
            // Find the room the client is in
            Room room = FindRoombyClientID(clientSocket);
            
            if (room != null)
            {
                int playerId = room.ClientId[clientSocket];
                string playerName = room.player[playerId].Item1;
                
                Console.WriteLine($"[DEBUG] Player {playerName} (ID: {playerId}) is disconnecting from room {room.id}");
                
                // Check if the game is in progress
                if (room.rommbg == 1)
                {
                    // Game is in progress, handle as player leaving during match
                    await HandlePlayerLeavingDuringMatch(room, playerId, playerName, authenticatedUserUid);
                }
                else
                {
                    // Game hasn't started yet, just remove the player
                    RemovePlayerFromRoom(room, playerId, clientSocket);
                }
            }
            
            // Update database status to offline
            if (!string.IsNullOrEmpty(authenticatedUserUid))
            {
                try
                {
                    DocumentReference userDoc = db.Collection("players").Document(authenticatedUserUid);
                    await userDoc.UpdateAsync("status", 0);
                    Console.WriteLine($"Đã cập nhật trạng thái thành offline cho người dùng: {authenticatedUserUid}");
                }
                catch (Exception dbEx)
                {
                    Console.WriteLine($"Lỗi khi cập nhật trạng thái offline cho {authenticatedUserUid}: {dbEx.Message}");
                }
            }
            
            // Remove from authenticated players
            authenticatedPlayers.TryRemove(clientSocket, out _);
            
            // Terminate and remove the client thread
            if (clientThreads.TryRemove(clientSocket, out var threadInfo))
            {
                Console.WriteLine($"[DEBUG] Terminating client thread for {username}");
                
                // Cancel the cancellation token to signal the thread to stop
                threadInfo.CancellationTokenSource.Cancel();
                
                // Check if thread is still alive and wait for it to terminate
                if (threadInfo.Thread.IsAlive)
                {
                    try
                    {
                        // Wait for the thread to terminate gracefully (max 5 seconds)
                        if (threadInfo.Thread.Join(5000))
                        {
                            Console.WriteLine($"[DEBUG] Client thread terminated gracefully for {username}");
                        }
                        else
                        {
                            Console.WriteLine($"[WARNING] Client thread did not terminate gracefully for {username}, forcing termination");
                            // Force termination if graceful termination fails
                            threadInfo.Thread.Interrupt();
                        }
                    }
                    catch (Exception threadEx)
                    {
                        Console.WriteLine($"[ERROR] Error terminating client thread for {username}: {threadEx.Message}");
                    }
                }
                else
                {
                    Console.WriteLine($"[DEBUG] Client thread already terminated for {username}");
                }
                
                // Dispose the cancellation token source
                threadInfo.CancellationTokenSource.Dispose();
            }
            else
            {
                Console.WriteLine($"[WARNING] Client thread not found for {username}");
            }
            
            // Close the socket
            clientSocket.Close();
            
            Console.WriteLine($"[DEBUG] Disconnection handling completed for {username}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[ERROR] Error handling client disconnection: {ex.Message}");
            Console.WriteLine($"[ERROR] Stack trace: {ex.StackTrace}");
        }
    }

    private async Task HandlePlayerLeavingDuringMatch(Room room, int leavingPlayerId, string leavingPlayerName, string authenticatedUserUid)
    {
        Console.WriteLine($"[DEBUG] Player {leavingPlayerName} left during match in room {room.id}");
        
        // Get remaining players
        var remainingPlayers = new List<(int id, string name, Socket socket)>();
        foreach (var kvp in room.player)
        {
            int playerId = kvp.Key;
            string playerName = kvp.Value.Item1;
            Socket socket = kvp.Value.Item2;
            
            if (playerId != leavingPlayerId && socket != null && socket.Connected)
            {
                remainingPlayers.Add((playerId, playerName, socket));
            }
        }
        
        // Remove the leaving player from the room
        RemovePlayerFromRoom(room, leavingPlayerId, room.player[leavingPlayerId].Item2);
        
        // If there are remaining players, notify them about the disconnection
        if (remainingPlayers.Count > 0)
        {
            Console.WriteLine($"[DEBUG] {remainingPlayers.Count} players remaining, notifying about disconnection");
            
            // Notify all remaining players about the disconnection
            foreach (var (playerId, playerName, socket) in remainingPlayers)
            {
                try
                {
                    // Send disconnection notification message
                    string disconnectMessage = $"PlayerDisconnected: {leavingPlayerName}\n";
                    byte[] buffer = Encoding.UTF8.GetBytes(disconnectMessage);
                    socket.Send(buffer);
                    
                    Console.WriteLine($"[DEBUG] Notified player {playerName} about disconnection");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[ERROR] Error notifying player {playerName}: {ex.Message}");
                }
            }
        }
        
        // Delete the room since the match is over
        Console.WriteLine($"[DEBUG] Deleting room {room.id} due to player disconnection");
        DeleteRoom(room);
    }

    private void RemovePlayerFromRoom(Room room, int playerId, Socket clientSocket)
    {
        try
        {
            // Remove from ClientId dictionary
            room.ClientId.Remove(clientSocket);
            
            // Clear the player slot
            room.player[playerId] = (string.Empty, null);
            
            // Reset ready status for this player
            room.countrd[playerId] = 0;
            room.sumcountrd = room.countrd[1] + room.countrd[2] + room.countrd[3] + room.countrd[4];
            
            // Clear player hand
            if (room.playerHands.ContainsKey(playerId))
            {
                room.playerHands[playerId].Clear();
            }
            
            // Reset Uno called status
            room.UnoCalled[playerId] = false;
            
            Console.WriteLine($"[DEBUG] Removed player {playerId} from room {room.id}");
            
            // Update ready status for remaining players
            string status = $"{room.countrd[1]},{room.countrd[2]},{room.countrd[3]},{room.countrd[4]}";
            string messageToClients = $"isPlay: {status}\n";
            Broadcast(room, messageToClients);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[ERROR] Error removing player from room: {ex.Message}");
        }
    }

    private void LogThreadStatistics()
    {
        int activeThreads = clientThreads.Count(kvp => kvp.Value.Thread.IsAlive);
        int totalThreads = clientThreads.Count;
        
        Console.WriteLine($"[DEBUG] Thread Statistics - Active: {activeThreads}, Total: {totalThreads}");
        
        // Log details of each thread
        foreach (var kvp in clientThreads)
        {
            Socket socket = kvp.Key;
            var threadInfo = kvp.Value;
            Console.WriteLine($"[DEBUG] Thread {threadInfo.Thread.ManagedThreadId} - Alive: {threadInfo.Thread.IsAlive}, Socket: {socket.Connected}");
        }
    }



    private bool IsPlayable(string card, Room room)
    {
        char cardColor = (card == "DD" || card == "DP") ? room.pendingWildColor : card[0];
        string cardValue = (card == "DD" || card == "DP") ? card : card.Substring(1);
        // Kiểm tra theo màu hiện tại hoặc giá trị
        return cardColor == room.pendingWildColor
               || cardValue == room.currentValue
               || card == "DD"
               || card == "DP";
    }

    private class Room
    {
        //thêm constructor tùy chỉnh sau
        public int currentTurn;
        public int pendingDrawCards = 0; //stack card cần rút
        public char pendingWildColor = 'W'; // Màu mặc định cho Wild
        public string currentValue; // Giá trị bài hiện tại
        public ConcurrentDictionary<int, ConcurrentQueue<string>> playerHands
            = new ConcurrentDictionary<int, ConcurrentQueue<string>>();
        public Dictionary<int, string> PlayerNames { get; } = new Dictionary<int, string>();
        public bool mustPlayColor = false;
        public char forcedColor;
        public Dictionary<int, bool> UnoCalled = new Dictionary<int, bool>();
        public bool CatchOccurred = false;
        public bool isReversed { get; set; } = false;
        public Room(int id)
        {
            currentTurn = 1;
            this.id = id;
            player.Add(1, (string.Empty, null));
            player.Add(2, (string.Empty, null));
            player.Add(3, (string.Empty, null));
            player.Add(4, (string.Empty, null));
            for (int i = 1; i <= 4; i++)
                playerHands.TryAdd(i, new ConcurrentQueue<string>());
            // Khởi tạo UnoCalled cho các player 1–4
            for (int i = 1; i <= 4; i++)
                UnoCalled[i] = false;

            countrd = new int[5];
            InitializeCardQueue();
        }
        public int rommbg; // lưu trữ thông tin phòng đã bắt đầu chơi hay chưa
        public int id;
        // mảng lưu trữ thông tin người chơi trong phòng đã nhấn ready hay chưa
        public int[] countrd;
        public int sumcountrd = 0; // số người chơi trong phòng
                                   // 
        public Dictionary<Socket, int> ClientId = new Dictionary<Socket, int>();
        //một hashmap lưu trữ người chơi và socket mà họ dùng để kết nối tới server
        //<int, (string, Socket)>: 
        //int: id người chơi trong phòng đó (1 hoặc 2)
        //string: tên người chơi
        //Socket: socket người chơi sử dụng để kết nối tới server
        public Dictionary<int, (string, Socket)> player = new Dictionary<int, (string, Socket)>();
        public Queue<string> Dataqueue = new Queue<string>(); // bo bai chua danh
        public Queue<string> Dataqueue1 = new Queue<string>();// bo bai da danh

        // lấy bài        
        public void InitializeCardQueue()
        {
            string cardsDirectory = "..\\..\\..\\Resources\\UNOCards\\Uno.txt";

            // Read data from file and enqueue
            Dataqueue = ReadFileAndEnqueue(cardsDirectory);
            //bị lỗi
            //string filePath = Path.Combine(Directory.GetCurrentDirectory(), "Uno.txt");

            // Shuffle the queue elements
            ShuffleQueue(Dataqueue);
        }
        // trộn bài 
        public void ShuffleQueue(Queue<string> queue)
        {
            // Convert queue to list
            List<string> dataList = new List<string>(queue);
            // Use Fisher-Yates algorithm to shuffle list
            Random random = new Random();
            int n = dataList.Count;
            while (n > 1)
            {
                n--;
                int k = random.Next(n + 1);
                string value = dataList[k];
                dataList[k] = dataList[n];
                dataList[n] = value;
            }
            // Clear the queue
            queue.Clear();
            // Enqueue shuffled elements back to the queue
            foreach (string element in dataList)
            {
                queue.Enqueue(element);
            }
        }
        public Queue<string> ReadFileAndEnqueue(string filePath)
        {
            Queue<string> dataQueue = new Queue<string>();
            using (StreamReader reader = new StreamReader(filePath))
            {
                string line;
                while ((line = reader.ReadLine()) != null)
                {
                    // Remove newline character and split data into elements
                    string[] elements = line.Split(',');
                    // Enqueue elements
                    foreach (string element in elements)
                    {
                        dataQueue.Enqueue(element);
                    }
                }
            }
            return dataQueue;
        }

        // Method to shuffle queue elements


    }

    public void ServerThread()
    {
        //lần lượt khởi tạo IPEndPoint và socket, và bind socket này với IPEndPoint của server
        //để có thể tạo ra một TCPListener
        IPAddress serverIP = IPAddress.Parse("127.0.0.1");
        IPEndPoint serverIPEP = new IPEndPoint(serverIP, 10000);

        serverSocket = new Socket(
            AddressFamily.InterNetwork,
            SocketType.Stream,
            ProtocolType.Tcp
        );

        serverSocket.Bind(serverIPEP);
        serverSocket.Listen(10); //cho phép tối đa 10 yêu cầu kết nối một lúc
        isRunning = true;

        //xử lí yêu cầu client tại đây
        while (isRunning)
        {
            try
            {
                Socket acceptedClient = serverSocket.Accept();

                //tạo một luồng mới cho từng client được kết nối
                //nếu không thì server không thể giao tiếp với nhiều hơn 1 client
                var cancellationTokenSource = new CancellationTokenSource();
                Thread clientThread = new Thread(() => HandleClient(acceptedClient, cancellationTokenSource.Token));
                clientThreads.TryAdd(acceptedClient, (clientThread, cancellationTokenSource));
                clientThread.Start();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error: {ex.Message}");
            }
        }
    }
    // hàm tìm client theo socket
    private Room FindRoombyClientID(Socket ClientSocket)
    {
        return roomList.FirstOrDefault(room => room.ClientId.ContainsKey(ClientSocket));
    }
    // hàm chơi theo vòng 
    private int nextplayer(int currentPlayer, bool isReverse)
    {
        if (isReverse)
        {
            return currentPlayer == 1 ? 4 : currentPlayer - 1;
        }
        return currentPlayer == 4 ? 1 : currentPlayer + 1;
    }
    public void StartServer()
    {
        serverThread = new Thread(ServerThread);
        serverThread.Start();
        TestFirestoreConnection();
    }

    public void StopServer()
    {
        Console.WriteLine("[DEBUG] Stopping server and cleaning up client threads...");
        
        // Stop accepting new connections
        isRunning = false;
        
        // Close server socket
        if (serverSocket != null && serverSocket.Connected)
        {
            serverSocket.Close();
        }
        
        // Terminate all client threads
        foreach (var kvp in clientThreads)
        {
            Socket socket = kvp.Key;
            var threadInfo = kvp.Value;
            
            try
            {
                // Cancel the cancellation token to signal the thread to stop
                threadInfo.CancellationTokenSource.Cancel();
                
                if (threadInfo.Thread.IsAlive)
                {
                    Console.WriteLine($"[DEBUG] Terminating client thread {threadInfo.Thread.ManagedThreadId}");
                    
                    // Wait for graceful termination
                    if (!threadInfo.Thread.Join(3000)) // 3 second timeout
                    {
                        Console.WriteLine($"[WARNING] Forcing termination of client thread {threadInfo.Thread.ManagedThreadId}");
                        threadInfo.Thread.Interrupt();
                    }
                }
                
                // Dispose the cancellation token source
                threadInfo.CancellationTokenSource.Dispose();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[ERROR] Error terminating client thread {threadInfo.Thread.ManagedThreadId}: {ex.Message}");
            }
            
            try
            {
                if (socket.Connected)
                {
                    socket.Close();
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[ERROR] Error closing client socket: {ex.Message}");
            }
        }
        
        // Clear collections
        clientThreads.Clear();
        authenticatedPlayers.Clear();
        roomList.Clear();
        
        Console.WriteLine("[DEBUG] Server stopped and all resources cleaned up");
    }
}
```

### UNO\Arena.cs
```cs
﻿using Microsoft.IdentityModel.Tokens;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Linq;
using System.Net.NetworkInformation;
using System.Net.Sockets;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using static System.Runtime.InteropServices.JavaScript.JSType;
using static System.Windows.Forms.VisualStyles.VisualStyleElement;
using Timer = System.Windows.Forms.Timer;

namespace UNO
{
    public partial class Arena : Form
    {
        private NetworkStream stream;
        private string CardTop;
        public string playerName;
        public TcpClient TcpClient;
        private Panel emojiPanel;
        private Timer blinkTimer;
        private bool isBlinking = false;
        private Bitmap originalImageCard;
        private Bitmap originalImageIcon;
        private TableLayoutPanel emojiTable;
        private int columns = 3;
        private int rows = 3;
        private List<string> deck;      // bộ bài còn lại để rút
        private List<string> discardDeck = new List<string>(); // bo bai bo
        private Random rand = new Random();
        // trạng thái lá bài giữa và lượt chơi
        private string currentMiddleCard;
        private char currentColor;       // 'R','G','B','Y' hoặc 'W' (wild)
        private string currentValue;     // "0"-"9", "C","D","P", "DD","DP"
        private bool isPlayerTurn; // true: đến lượt client, false: đối thủ (sau này dùng mạng)
        private int myPlayerId;
        private int pendingDraw = 0;
        private bool unoCalled = false;
        private int targetId = -1;

        /* Một map lưu tất cả hình ảnh lá bài và key để truy xuất các phần tử đó
         * Quy ước về tên lá bài:
         * R, G, B, Y: Màu lá bài, lần lượt là đỏ, xanh lá cây, xanh biển, vàng
         * 0 - 9: Cho các lá số (VD: R9, G8, B7, Y6)
         * C: Lá skip (VD: RC, GC, BC, YC)
         * D: Lá đảo lượt (VD: RD, GD, BD, YD)
         * P: Lá +2 (VD: RP, GP, BP, YP)
         * DD: Lá chọn màu
         * DP: Lá +4
         */
        private Dictionary<string, Image> imageCards = new Dictionary<string, Image>();
        private readonly object playerHandLock = new object();
        //Lưu tên toàn bộ bài người chơi đang giữ
        private List<string> playerHand = new List<string>();

        //Lưu vị trí đầu tiên mà mình sẽ thực hiện in một lần 6 lá bài, khởi tạo là 0
        private int firstIndex = 0;

        //Lưu toàn bộ lá bài vào trong Dictionary/map với key là tên file (đã theo quy ước)
        private void LoadCards()
        {
            // đường dẫn chứa file thực thi là G:\PC\Coding\VS_repo\UNOv2\UNO\bin\Debug\net8.0-windows
            // đường dẫn cần xử lí là G:\PC\Coding\VS_repo\UNOv2\UNO\Resources\Cards
            // => cần xử lí cardsDirectory như trên để quay lại thư mục UNO
            string cardsDirectory = "..\\..\\..\\Resources\\Cards";
            string[] cardsName = System.IO.Directory.GetFiles(cardsDirectory);

            foreach (string cardName in cardsName)
            {
                string fileCardName = System.IO.Path.GetFileNameWithoutExtension(cardName);
                imageCards[fileCardName] = Image.FromFile(cardName);
            }
            deck = imageCards.Keys.ToList();
            ShuffleDeck();
        }

        private void InitializeMiddleCard()
        {
            DisplayMiddleCard(); // gọi ngay sau LoadCards(), trước DisplayFirstSixCards()
        }
        private void DisplayMiddleCard()
        {
            if (deck.Count == 0)
            {
                MessageBox.Show("Không còn bài để đặt giữa!");
                return;
            }

            // Rút lá đầu tiên trong deck (sau khi đã Shuffle)
            currentMiddleCard = deck[0];
            deck.RemoveAt(0);

            // Lấy màu và giá trị
            currentColor = currentMiddleCard[0];         // R/G/B/Y/DP/DD ...
            currentValue = currentMiddleCard.Substring(1);

            // Hiển thị ảnh
            this.Invoke((Action)(() =>
            {
                MiddlePictureBox.Image = imageCards[currentMiddleCard];
                MiddlePictureBox.Tag = currentMiddleCard;    // lưu lại key để truy xuất nếu cần
            }));
        }
        private void ShuffleDeck()
        {
            for (int i = deck.Count - 1; i > 0; i--)
            {
                int j = rand.Next(i + 1);
                var tmp = deck[j];
                deck[j] = deck[i];
                deck[i] = tmp;
            }
        }

        private void ShuffleDiscardDeck()
        {
            for (int i = discardDeck.Count - 1; i > 0; i--)
            {
                int j = rand.Next(i + 1);
                var tmp = discardDeck[j];
                discardDeck[j] = discardDeck[i];
                discardDeck[i] = tmp;
            }
        }

        //Update lá bài nằm ở giữa
        //Update danh sách lá bài, với việc thay đổi từng lá bài nằm ở hàm này
        //Tham số thứ hai chỉ ra picturebox nào sẽ bị thay đổi


        //Như tên hàm, xuất ra sáu lá bài đầu tiên, chủ yếu dùng khi mà người dùng mới vào trận
        private void DisplayFirstSixCards()
        {
            for (int i = 0; i < 6; i++)
            {
                //nếu danh sách bài người chơi có ít hơn 6 lá thì ngắt khi chỉ số vượt quá giới hạn
                if (i >= playerHand.Count) return;

                //Tìm pictureBox sẽ hiển thị lá bài ở vị trí tương ứng
                string pictureBoxName = "Card" + (i + 1).ToString();
                PictureBox pictureBox = this.Controls[pictureBoxName] as PictureBox;

                //Hiển thị lá bài tại pictureBox đã tìm được
                DisplayCard(playerHand[i], pictureBox);
            }
        }

        // Ba hàm dưới đây sử dụng biến firstIndex để hiển thị 6 lá bài từ danh sách lá bài của người dùng

        //Xử lí khi người dùng bấm nút next
        private void NextButton_Click(object sender, EventArgs e)
        {
            if (firstIndex + 6 >= playerHand.Count) return;
            firstIndex += 6;
            UpdateSixCards();
        }

        //Xử lí khi người dùng bấm nút back
        private void PreviousButton_Click(object sender, EventArgs e)
        {
            if (firstIndex - 6 < 0) return;
            firstIndex -= 6;
            UpdateSixCards();
        }

        //Hàm xử lí hiển thị lại các lá bài khi nhấn vào hai nút back/next 
        private void UpdateSixCards()
        {
            //reset ảnh toàn bộ 6 picturebox
            this.Invoke((Action)(() =>
            {
                for (int i = 1; i <= 6; i++)
                {
                    var pb = this.Controls[$"Card{i}"] as PictureBox;
                    pb.Image = Properties.Resources.pngtree_uno_card_png_image_9101654;
                    pb.Tag = null;
                }
            }));

            for (int i = firstIndex; i < firstIndex + 6; i++)
            {
                //nếu danh sách bài người chơi có ít hơn 6 lá thì ngắt khi chỉ số vượt quá giới hạn
                if (i >= playerHand.Count) return;

                //Tìm pictureBox sẽ hiển thị lá bài ở vị trí tương ứng
                string pictureBoxName = "Card" + ((i % 6) + 1).ToString();
                PictureBox pictureBox = this.Controls[pictureBoxName] as PictureBox;

                //Hiển thị lá bài tại pictureBox đã tìm được
                DisplayCard(playerHand[i], pictureBox);
            }
        }


        //Hàm kiểm tra tính hợp lệ của lá bài khi nhấn vào, nếu hợp lệ thì khi nhấn lần nữa sẽ chơi lá đó
        private void drawBtn_Click(object sender, EventArgs e) { }

        //helper function 
        private void RefillDeckFromDiscard()
        {
            // Giữ lại lá trên cùng
            var top = discardDeck.Last();
            discardDeck.RemoveAt(discardDeck.Count - 1);

            ShuffleDiscardDeck();
            deck.AddRange(discardDeck);
            discardDeck.Clear();
            discardDeck.Add(top);
            ShuffleDeck();
        }
        // Hàm xử lí yêu cầu rút thêm lá khi người dùng nhấn nút Draw
        private async Task DrawCards(int count)
        {
            // Chỉ gửi 1 yêu cầu "DrawCard" mỗi lần
            var msg = Encoding.UTF8.GetBytes("DrawCard\n");
            await stream.WriteAsync(msg, 0, msg.Length);
        }



        //Hàm sắp xếp lại danh sách bài người chơi
        private void sortBtn_Click(object sender, EventArgs e) { }

        public Arena(string playerName, TcpClient playerSocket, string roomName)
        {
            InitializeComponent();
            InitializeCustomComponents();
            InitializeEmojiPanel();
            originalImageCard = new Bitmap(Properties.Resources.pngtree_uno_card_png_image_9101654);
            imojiButon.Cursor = Cursors.Hand;
            imojiButon.Click += pictureBox1_Click;
            imojiButon.MouseEnter += pictureBox1_MouseEnter;
            imojiButon.MouseLeave += pictureBox1_MouseLeave;
            setting.MouseDown += setting_MouseDown;
            setting.MouseUp += setting_MouseUp;
            Room.Text += " " + roomName;
            btnUno.Visible = false;
            btnCatch.Visible = false;
            sendBtn.Visible = false;
            chatBox.Visible = false;
            chatInput.Visible = false;

            this.playerName = playerName;
            this.TcpClient = playerSocket;
            //định nghĩa các hàm khi vào trận
            LoadCards();

            // Add form closing event handler
            this.FormClosing += Arena_FormClosing;

            this.Shown += Arena_Shown;
        }

        private void DisplayCard(string cardName, PictureBox pictureBox)
        {
            this.Invoke((Action)(() =>
            {
                pictureBox.Image = imageCards[cardName];
                pictureBox.Tag = cardName;      // rất quan trọng để lấy lại key khi click
            }));

        }
        private void setting_MouseDown(object sender, MouseEventArgs e)
        {
            Bitmap settingImage = new Bitmap(setting.Image);
            setting.Image = AdjustBrightness(settingImage, 0.8f);
        }

        private void setting_MouseUp(object sender, MouseEventArgs e)
        {
            setting.Image = Properties.Resources.light_blue_settings_gear_22453__1_;
        }
        private void InitializeCustomComponents()
        {
            imojiButon.Parent = this;
            MiddlePictureBox.Image = Properties.Resources.pngtree_uno_card_png_image_9101654;
            MiddlePictureBox.BackColor = Color.Transparent;
            MiddlePictureBox.SizeMode = PictureBoxSizeMode.StretchImage;
            imojiButon.Image = Properties.Resources._19822c18e912ad0ffb2ad2faed8a61af__1__removebg_preview1;
            imojiButon.BackColor = Color.Transparent;
            imojiButon.SizeMode = PictureBoxSizeMode.StretchImage;
            imojiButon.Parent = this;
            imojiButon.Cursor = Cursors.Hand;
            imojiButon.Click += pictureBox1_Click;
            this.DoubleBuffered = true;
            AvatarPlayer.Image = Properties.Resources.avatar_removebg_preview;
            AvatarPlayer.BackColor = Color.Transparent;
            AvatarPlayer.SizeMode = PictureBoxSizeMode.StretchImage;
            Enemy.Image = Properties.Resources.avatar_removebg_preview;
            Enemy.BackColor = Color.Transparent;
            Enemy.SizeMode = PictureBoxSizeMode.StretchImage;
            setting.Image = Properties.Resources.light_blue_settings_gear_22453__1_;
            setting.BackColor = Color.Transparent;
            setting.SizeMode = PictureBoxSizeMode.StretchImage;
            foreach (var i in Enumerable.Range(1, 6))
            {
                var pb = this.Controls[$"Card{i}"] as PictureBox;
                pb.Click += PlayerCard_Click;
            }

            setting.Cursor = Cursors.Hand;
        }


        private string pendingCard = null;  // lá đã click lần 1

        private void PlayerCard_Click(object sender, EventArgs e)
        {
            ClearPendingHighlight();
            var pb = sender as PictureBox;
            if (pb == null || pb.Tag == null) return;

            string cardName = pb.Tag.ToString();

            // Nếu chưa tới lượt thì cảnh báo
            if (!isPlayerTurn)
            {
                MessageBox.Show("Chưa đến lượt bạn!", "UNO", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            // Lần click đầu: kiểm tra hợp lệ
            if (pendingCard == null)
            {
                if (!IsValidMove(cardName))
                {
                    MessageBox.Show("Bạn không thể đánh lá này!", "UNO", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                    return;
                }
                ClearPendingHighlight();
                pendingCard = cardName;
                pb.BorderStyle = BorderStyle.Fixed3D;  // highlight
                pb.BackColor = Color.Yellow; // Thêm màu nền để dễ nhận biết
                if (playerHand.Count == 2)
                {
                    btnUno.Visible = true;
                }

                return;
            }

            // Lần click hai: phải cùng lá với pending, thực sự đánh
            if (cardName != pendingCard)
            {
                if (!IsValidMove(cardName))
                {
                    MessageBox.Show("Lá này không hợp lệ, vui lòng chọn lá khác hoặc nhấn Draw.", "UNO", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                    return;
                }
                // bấm lá khác thì xóa highlight cũ và set lá mới
                ClearPendingHighlight();
                pendingCard = cardName;
                pb.BorderStyle = BorderStyle.Fixed3D;
                pb.BackColor = Color.Yellow;
                return;
            }

            // Xử lý đánh
            pb.BorderStyle = BorderStyle.None;
            ClearPendingHighlight();  // xoá highlight
            pb.BackColor = Color.Transparent;
            PlayCard(cardName, pb);
            pendingCard = null;
        }
        private void PlayCard(string cardName, PictureBox pb)
        {
            char newColor = currentColor;
            string message;

            // 1. Xoá khỏi tay

            // 2. Update UI: xoá pictureBox hoặc đổi sang lá úp
            pb.Image = Properties.Resources.pngtree_uno_card_png_image_9101654;
            pb.Tag = null;
            // Sau khi gọi PlayCard và gửi thông điệp xong:

            // 3. Nếu là đổi màu (DD hoặc DP), hỏi chọn màu mới
            if (cardName == "DD" || cardName == "DP")
            {
                newColor = PromptForColor();
                message = $"PlayCard: {cardName}|{newColor}\n";
            }
            else if (cardName.EndsWith("P"))
            {
                message = $"PlayCard: {cardName}|{currentColor}\n";
            }
            else
            {
                message = $"PlayCard: {cardName}\n";
            }
            Console.WriteLine($"[DEBUG] Pre-Remove hand: {string.Join(",", playerHand)}");
            lock (playerHandLock)
            {
                playerHand.Remove(cardName);
                playerHand.Sort();
            }
            Console.WriteLine($"[DEBUG] Post-Remove hand: {string.Join(",", playerHand)}");
            this.Invoke((Action)(() => UpdateSixCards()));
            discardDeck.Add(cardName);

            // Gửi message
            byte[] buffer = Encoding.UTF8.GetBytes(message);
            stream.Write(buffer, 0, buffer.Length);
            // Cập nhật trạng thái
            currentMiddleCard = cardName;
            currentColor = newColor;
            currentValue = cardName.EndsWith("P") ? "P" : cardName.Substring(1);

            // Update UI
            MiddlePictureBox.Image = imageCards[cardName];
            MiddlePictureBox.Tag = cardName;
            // TODO: gửi trạng thái mạng cho đối thủ hoặc gọi hàm xử lý lượt đối thủ
            btnUno.Visible = false;
        }
        private char PromptForColor()
        {
            // Cách đơn giản: MessageBox 4 nút hoặc ColorDialog
            using (Form f = new Form())
            {
                f.Text = "Chọn màu";
                var panel = new FlowLayoutPanel { Dock = DockStyle.Fill };
                foreach (var kv in new Dictionary<char, string>
                 { {'R',"Đỏ"}, {'G',"Xanh lá"}, {'B',"Xanh dương"}, {'Y',"Vàng"} })
                {
                    var btn = new System.Windows.Forms.Button { Text = kv.Value, Tag = kv.Key, AutoSize = true };
                    btn.Click += (s, e) => { f.Tag = ((System.Windows.Forms.Button)s).Tag; f.Close(); };
                    panel.Controls.Add(btn);
                }
                f.Controls.Add(panel);
                f.StartPosition = FormStartPosition.CenterParent;
                f.ShowDialog();
                return f.Tag != null ? (char)f.Tag : 'R';
            }
        }
        private bool IsValidMove(string card)
        {
            char topColor = currentColor;
            string topValue = currentValue;
            char cardColor = card[0];
            string cardValue = card.Substring(1);

            // Đang phạt
            if (pendingDraw > 0)
            {
                if (topValue == "DP") // +4
                {
                    return card == "DP";
                }
                else if (topValue == "P") // +2
                {
                    return card.EndsWith("P") || card == "DP";
                }
            }

            // Nếu lá trên cùng là Wild (DD)
            if (topValue == "DD")
            {
                if (card == "DD" || card == "DP") return true;
                return cardColor == topColor;
            }

            // Luật bình thường
            if (card == "DD" || card == "DP") return true;
            return (cardColor == topColor || cardValue == topValue);
        }
        private Bitmap AdjustBrightness(Bitmap image, float brightness)
        {
            Bitmap adjustedImage = new Bitmap(image.Width, image.Height);
            using (Graphics g = Graphics.FromImage(adjustedImage))
            {
                float[][] matrix = {
                new float[] {brightness, 0, 0, 0, 0},
                new float[] {0, brightness, 0, 0, 0},
                new float[] {0, 0, brightness, 0, 0},
                new float[] {0, 0, 0, 1f, 0},
                new float[] {0, 0, 0, 0, 1f}
            };

                ColorMatrix colorMatrix = new ColorMatrix(matrix);
                using (ImageAttributes attributes = new ImageAttributes())
                {
                    attributes.SetColorMatrix(colorMatrix);
                    g.DrawImage(
                        image,
                        new Rectangle(0, 0, image.Width, image.Height),
                        0, 0, image.Width, image.Height,
                        GraphicsUnit.Pixel,
                        attributes
                    );
                }
            }
            return adjustedImage;
        }
        private void ApplyClickEffect()
        {
            MiddlePictureBox.Image = AdjustBrightness(originalImageCard, 0.8f); // Giảm độ sáng
            blinkTimer.Start();
        }
        private void ApplyHoverEffect()
        {
            MiddlePictureBox.Image = AdjustBrightness(originalImageCard, 1.2f);
        }
        private void InitializeEmojiPanel()
        {
            emojiPanel = new Panel();
            emojiPanel.Size = new Size(100, 100);
            emojiPanel.Location = new Point(imojiButon.Left, imojiButon.Top - emojiPanel.Height - 10);
            emojiPanel.BackColor = Color.Transparent;
            emojiPanel.BorderStyle = BorderStyle.FixedSingle;
            emojiPanel.Paint += EmojiPanel_Paint;
            emojiTable = new TableLayoutPanel();
            emojiTable.ColumnCount = columns;
            emojiTable.RowCount = rows;
            emojiTable.Dock = DockStyle.Fill;
            emojiTable.BackColor = Color.Transparent;
            for (int i = 0; i < columns; i++)
                emojiTable.ColumnStyles.Add(new ColumnStyle(SizeType.Percent, 100f / columns));
            for (int i = 0; i < rows; i++)
                emojiTable.RowStyles.Add(new RowStyle(SizeType.Percent, 100f / rows));
            string[] emojis = new string[] { "😀", "😂", "😍", "😎", "😢", "😡", "👍", "👎", "🙏" };
            foreach (var emoji in emojis)
            {
                Label lblEmoji = new Label();
                lblEmoji.Text = emoji;
                lblEmoji.Dock = DockStyle.Fill;
                lblEmoji.TextAlign = ContentAlignment.MiddleCenter;
                lblEmoji.Font = new Font("Segoe UI Emoji", 24);
                lblEmoji.ForeColor = Color.Yellow;
                lblEmoji.Cursor = Cursors.Hand;
                lblEmoji.Click += Emoji_Click;

                lblEmoji.MouseEnter += (s, e) =>
                {
                    Label lbl = s as Label;
                    if (lbl != null)
                        lbl.ForeColor = Color.Red;
                };
                lblEmoji.MouseLeave += (s, e) =>
                {
                    Label lbl = s as Label;
                    if (lbl != null)
                        lbl.ForeColor = Color.Yellow; // Màu mặc định
                };

                // Thêm emoji vào bảng chứ không trực tiếp vào panel
                emojiTable.Controls.Add(lblEmoji);
            }

            emojiTable.Resize += EmojiTable_Resize;
            emojiPanel.Controls.Add(emojiTable);

            emojiPanel.Visible = false;  // Ẩn panel khi khởi tạo
            this.Controls.Add(emojiPanel);
            emojiPanel.BringToFront();
        }

        private void EmojiTable_Resize(object sender, EventArgs e)
        {
            // Tính kích thước của mỗi ô trong bảng
            float cellWidth = (float)emojiTable.ClientSize.Width / columns;
            float cellHeight = (float)emojiTable.ClientSize.Height / rows;
            // Chọn kích thước font phù hợp: lấy giá trị nhỏ hơn của cellWidth và cellHeight, nhân với một hệ số điều chỉnh (ví dụ 0.5f)
            float newFontSize = Math.Min(cellWidth, cellHeight) * 0.5f;

            // Cập nhật font của tất cả các Label trong bảng
            foreach (Control ctrl in emojiTable.Controls)
            {
                if (ctrl is Label lbl)
                {
                    lbl.Font = new Font("Segoe UI Emoji", newFontSize);
                }
            }
        }
        private void EmojiPanel_Paint(object sender, PaintEventArgs e)
        {
            // Vẽ khung viền hình vuông (màu đen, độ dày 1)
            ControlPaint.DrawBorder(e.Graphics, emojiPanel.ClientRectangle, Color.Black, 1, ButtonBorderStyle.Solid,
                                                                      Color.Black, 1, ButtonBorderStyle.Solid,
                                                                      Color.Black, 1, ButtonBorderStyle.Solid,
                                                                      Color.Black, 1, ButtonBorderStyle.Solid);
        }

        private void pictureBox1_Click(object sender, EventArgs e)
        {
            emojiPanel.Visible = !emojiPanel.Visible;
            if (emojiPanel.Visible)
            {
                emojiPanel.BringToFront();
            }
        }
        private void PictureBox_MouseEnter(object sender, EventArgs e) => ApplyHoverEffect();
        private void PictureBox_MouseLeave(object sender, EventArgs e) => MiddlePictureBox.Image = originalImageCard;
        private void PictureBox_MouseDown(object sender, MouseEventArgs e) => ApplyClickEffect();
        private void PictureBox_MouseUp(object sender, MouseEventArgs e) => MiddlePictureBox.Image = originalImageCard;
        private System.Windows.Forms.Timer aTimer;
        private int counter = 10; // Giá trị khởi tạo
        private void drawCard_Click(object sender, EventArgs e)
        {

        }
        private void Form1_Resize(object sender, EventArgs e)
        {
            this.FormBorderStyle = FormBorderStyle.FixedSingle; // Hoặc FixedDialog
            this.MaximizeBox = false;
        }

        private void drawCard_MouseEnter(object sender, EventArgs e)
        {

        }

        private void drawCard_MouseLeave(object sender, EventArgs e)
        {

        }


        private void pictureBox1_MouseEnter(object sender, EventArgs e)
        {

        }

        private void pictureBox1_MouseLeave(object sender, EventArgs e)
        {

        }
        private void Emoji_Click(object sender, EventArgs e)
        {
            Label lbl = sender as Label;
            if (lbl != null)
            {
                // Add emoji to chat input
                chatInput.Text += lbl.Text;
                chatInput.Focus();
                chatInput.SelectionStart = chatInput.Text.Length;

                // Hide emoji panel after selection
                emojiPanel.Visible = false;
            }
        }

        public async void Arena_Shown(object sender, EventArgs e)
        {
            try
            {
                stream = TcpClient.GetStream();
                await ReceiveMessagesfromsv();
            }
            catch (Exception ex)
            {
                MessageBox.Show("Error connecting to server: " + ex.Message);
            }

        }

        private void AvatarPlayer_Click(object sender, EventArgs e)
        {
            // Xử lý khi click vào AvatarPlayer
        }

        private void Enemy_Click(object sender, EventArgs e)
        {
            // Xử lý khi click vào Enemy
        }

        private void setting_Click(object sender, EventArgs e)
        {
            // Xử lý khi click vào setting
        }

        private void imojiButon_Click(object sender, EventArgs e)
        {
            // Xử lý khi click vào imojiButon
        }

        private void ClockIcon_Click(object sender, EventArgs e)
        {
            // Xử lý khi click vào ClockIcon
        }

        private void clock1_Click(object sender, EventArgs e)
        {
            // Xử lý khi click vào clock1
        }

        private void setting_Click_1(object sender, EventArgs e)
        {

        }

        private void label1_Click(object sender, EventArgs e)
        {
        }
        private void aTimer_Tick(object sender, EventArgs e)
        {
            counter--;

            if (counter == 0)
            {
                aTimer.Stop();
                aTimer.Dispose();
            }

            TimeMe.Text = counter.ToString();
        }
        private TaskCompletionSource<bool> turnTcs;
        private async void button1_Click(object sender, EventArgs e)
        {
            if (!isPlayerTurn)
            {
                MessageBox.Show("Chưa đến lượt bạn!", "UNO", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }
            if (HasPlayableCard())
            {
                MessageBox.Show("Bạn có lá bài hợp lệ, không thể rút thêm!", "UNO", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Nếu đang bị phạt
            if (pendingDraw > 0)
            {
                MessageBox.Show($"Bạn đang bị phạt {pendingDraw} lá!", "UNO", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            // Trường hợp bình thường (không phạt): rút 1 lá mỗi click
            await DrawCards(1);
            UpdateSixCards();
            DrawButton.Enabled = isPlayerTurn;
        }


        // Helper kiểm tra lá bình thường (không tính pendingDraw)
        private bool IsValidNormalMove(string card)
        {
            char topColor = currentColor;
            string topValue = currentValue;
            char cardColor = card[0];
            string cardValue = card.Substring(1);

            if (card == "DD" || card == "DP") return true;
            return (cardColor == topColor || cardValue == topValue);
        }
        // Hàm tìm PictureBox chứa lá bài cụ thể
        private PictureBox FindPictureBoxForCard(string cardName)
        {
            foreach (Control control in this.Controls)
            {
                if (control is PictureBox pb && pb.Tag?.ToString() == cardName)
                    return pb;
            }
            return null;
        }

        private void Card5_Click(object sender, EventArgs e)
        {

        }

        private void Card6_Click(object sender, EventArgs e)
        {

        }

        private void Card2_Click(object sender, EventArgs e)
        {

        }
        // hàm sort theo màu và số 
        private void SortButton_Click(object sender, EventArgs e)
        {
            playerHand.Sort();

            UpdateSixCards();
        }
        private void ClearPendingHighlight()
        {
            // Lặp qua các PictureBox Card1…Card6
            for (int i = 1; i <= 6; i++)
            {
                var pb = this.Controls[$"Card{i}"] as PictureBox;
                if (pb != null)
                {
                    pb.BorderStyle = BorderStyle.None;
                    pb.BackColor = Color.Transparent; // Reset màu nền
                }
            }
        }

        private void Card1_Click(object sender, EventArgs e)
        {

        }
        private async Task ReceiveMessagesfromsv()
        {
            try
            {
                using var reader = new StreamReader(stream, Encoding.UTF8);
                while (true)
                {
                    if (TcpClient == null || !TcpClient.Connected)
                    {
                        // marshal MessageBox onto UI thread
                        if (this.InvokeRequired)
                        {
                            this.Invoke((Action)(() =>
                                MessageBox.Show("Not connected to server. Please reconnect.")
                            ));
                        }
                        else
                        {
                            MessageBox.Show("Not connected to server. Please reconnect.");
                        }
                        return;
                    }

                    string msg = await reader.ReadLineAsync(); // Chuyển đổi dữ liệu nhận được thành chuỗi
                    if (msg.StartsWith("isPlay: "))
                    {

                        var IsPlayControls = new[] { isPlay1, isPlay2, isPlay3, isPlay4 };
                        // lưu mảng toàn bộ các controls trong form arena
                        var labelControls = new[] { TimeMe, TimeEnemy };

                        var buttonControls = new[] { DrawButton, PreviousButton, NextButton, SortButton, sendBtn };
                        var pictureBoxControls = new[]
                        {
                            MiddlePictureBox,
                            AvatarPlayer,
                            Enemy,
                            setting,
                            imojiButon,
                            ClockIcon,
                            clock1,
                            Card1,
                            Card2,
                            Card3,
                            Card4,
                            Card5,
                            Card6,
                        };
                        //foreach (var control in IsPlayControls)
                        //{
                        //    this.Invoke((Action)(() =>
                        //    {
                        //        control.BackColor = Color.White;
                        //    }));
                        //}
                        string[] IdCards = msg.Split(':')[1].Trim().Split(','); // Lấy danh sách ID từ thông báo

                        //for (int i = 0; i < IdCards.Length; i++)
                        //{
                        //    //MessageBox.Show(IdCards[i]);
                        //    if (IdCards[i] == "1")
                        //    {
                        //        this.Invoke((Action)(() =>
                        //        {
                        //            IsPlayControls[i].BackColor = Color.Yellow;
                        //        }));         
                        //    }
                        //}
                        if (IdCards.All(id => id.Trim() == "1"))
                        {

                            // Fix for CS0119: 'Action' is a type, which is not valid in the given context
                            // The issue is caused by an incorrect cast syntax. The correct syntax is to cast to `Action` without parentheses.

                            this.Invoke((Action)(() =>
                            {
                                foreach (var control in IsPlayControls)
                                {
                                    control.Visible = false;
                                }
                                // Your code here
                                // Example: Update UI elements
                                foreach (var control in pictureBoxControls)
                                {
                                    control.Visible = true;
                                }
                                foreach (var control in buttonControls)
                                {
                                    control.Visible = true;
                                }
                                foreach (var control in labelControls)
                                {
                                    control.Visible = true;
                                }
                                chatBox.Visible = true;
                                chatInput.Visible = true;
                            }));
                        }
                        else
                        {
                            this.Invoke((Action)(() =>
                            {
                                for (int i = 0; i < IsPlayControls.Length; i++)
                                {
                                    IsPlayControls[i].BackColor = IdCards[i].Trim() == "1"
                                                                  ? Color.Yellow
                                                                  : Color.White;
                                }
                            }));
                        }
                    }
                    else if (msg.StartsWith("CardTop: "))
                    {
                        var p = msg.Substring(9).Split('|');
                        currentMiddleCard = p[0].Trim();
                        // Cập nhật màu: nếu có wild chọn màu thì p[1], ngược lại lấy màu từ chữ cái đầu
                        currentColor = p.Length > 1 ? p[1][0] : currentMiddleCard[0];

                        // **QUAN TRỌNG**: Cập nhật giá trị (value) mới để cho phép đánh cùng value
                        //   Wild: DD (chọn màu), DP (+4) giữ nguyên tên
                        //   Các lá khác: substring từ index 1
                        currentValue = (currentMiddleCard == "DD" || currentMiddleCard == "DP")
                                          ? currentMiddleCard
                                          : currentMiddleCard.Substring(1);
                        MiddlePictureBox.Image = imageCards[currentMiddleCard];
                    }
                    //handling draw card request
                    else if (msg.StartsWith("InitialHand: "))
                    {
                        //get the draw amount
                        string[] cards = msg.Substring("InitialHand: ".Length).Split(',');
                        playerHand.Clear();
                        foreach (string card in cards)
                        {
                            playerHand.Add(card.Trim());
                        }
                        this.Invoke((Action)(() => DisplayFirstSixCards()));
                    }
                    else if (msg.StartsWith("PendingDraw: "))
                    {
                        pendingDraw = int.Parse(msg.Substring("PendingDraw: ".Length).Trim());
                        DrawButton.Enabled = isPlayerTurn;
                    }
                    else if (msg.StartsWith("Turn: "))
                    {
                        int id = int.Parse(msg.Substring(6));
                        isPlayerTurn = (id == myPlayerId);
                        DrawButton.Enabled = isPlayerTurn && pendingDraw == 0;

                        if (isPlayerTurn)
                            unoCalled = false; // reset mỗi lượt
                    }
                    else if (msg.StartsWith("Room: "))
                    {
                        string roomId = msg.Substring("Room: ".Length).Trim();
                        // Lưu ID phòng (nếu cần)
                    }
                    else if (msg.StartsWith("YourId: "))
                    {
                        int myId = int.Parse(msg.Substring("YourId: ".Length).Trim());
                        myPlayerId = myId;
                        Console.WriteLine($"My Player ID: {myPlayerId}");
                        // Lưu myId vào biến để sử dụng khi xử lý lượt
                    }
                    else if (msg.StartsWith("DrawCard: "))
                    {
                        string card = msg.Substring("DrawCard: ".Length).Trim();
                        playerHand.Add(card);

                        this.Invoke((Action)(() =>
                        {
                            UpdateSixCards();
                            // highlight nếu cần
                            if (IsValidMove(card))
                            {
                                var pb = FindPictureBoxForCard(card);
                                if (pb != null)
                                {
                                    pb.BorderStyle = BorderStyle.Fixed3D;
                                    pb.BackColor = Color.Yellow;
                                }
                            }
                        }));
                    }
                    if (msg.StartsWith("CatchWindow: "))
                    {
                        targetId = int.Parse(msg.Substring("CatchWindow: ".Length).Trim());
                        Console.WriteLine("[DEBUG] Nhận CatchWindow cho targetId: " + targetId + ", myId: " + myPlayerId);

                        bool showCatch = (myPlayerId != targetId);
                        this.Invoke((Action)(() =>
                        {
                            btnCatch.Visible = showCatch;
                        }));

                        Console.WriteLine("[DEBUG] Catch nút hiện lên: " + (showCatch ? "TRUE" : "FALSE"));
                    }



                    else if (msg.StartsWith("PlayerWin: "))
                    {
                        // lưu mảng toàn bộ các controls trong form arena
                        var labelControls = new[] { TimeMe, TimeEnemy };

                        var buttonControls = new[] { DrawButton, PreviousButton, NextButton, SortButton, sendBtn };
                        var pictureBoxControls = new[]
                        {
                            MiddlePictureBox,
                            AvatarPlayer,
                            Enemy,
                            setting,
                            imojiButon,
                            ClockIcon,
                            clock1,
                            Card1,
                            Card2,
                            Card3,
                            Card4,
                            Card5,
                            Card6,
                        };
                        string winner = msg.Substring("PlayerWin: ".Length).Trim();
                        //this.Invoke((Action)(() =>
                        //    MessageBox.Show($"{winner} đã chiến thắng", "Kết thúc trò chơi", MessageBoxButtons.OK)
                        //));
                        this.Invoke((Action)(() =>
                        {
                            foreach (var control in pictureBoxControls)
                            {
                                control.Visible = false;
                            }
                            foreach (var control in buttonControls)
                            {
                                control.Visible = false;
                            }
                            foreach (var control in labelControls)
                            {
                                control.Visible = false;
                            }
                            chatBox.Visible = false;
                            chatInput.Visible = false;

                            //hiển thị thông tin liên quan đến kết quả
                            resultLabel.Text = $"{winner} đã chiến thắng!";
                            resultLabel.Visible = true;
                            scoreLabel.Visible = true;
                            backBtn.Visible = true;


                        }));
                    }
                    else if (msg.StartsWith("AutoDrawCount: "))
                    {
                        int count = int.Parse(msg.Substring("AutoDrawCount: ".Length).Trim());
                        // Hiển thị thông báo (MessageBox hoặc label tuỳ bạn)
                        this.Invoke((Action)(() =>
                        {
                            MessageBox.Show($"Bạn sẽ bị rút {count} lá do hiệu ứng +2/+4!", "Thông báo",
                                            MessageBoxButtons.OK, MessageBoxIcon.Information);
                        }));
                    }
                    else if (msg.StartsWith("Chat: "))
                    {
                        string[] parts = msg.Substring(6).Trim().Split('|', 2);
                        string playerName = parts[0];
                        string msgContent = parts[1];
                        this.Invoke((Action)(() =>
                        {
                            chatBox.AppendText($"{playerName}: {msgContent}\n");
                        }));
                    }
                    else if (msg.StartsWith("PlayerDisconnected: "))
                    {
                        string disconnectedPlayer = msg.Substring("PlayerDisconnected: ".Length).Trim();
                        this.Invoke((Action)(() =>
                        {
                            MessageBox.Show($"{disconnectedPlayer} has disconnected from the game.\nThe match has been ended.",
                                           "Player Disconnected",
                                           MessageBoxButtons.OK,
                                           MessageBoxIcon.Information);

                            // Return to menu
                            this.Hide();
                            Menu Form1 = new Menu(playerName, TcpClient);
                            Form1.Show();
                        }));
                    }
                    else if (msg.StartsWith("HideCatchWindow"))
                    {
                        // Ẩn luôn nút Catch trên tất cả client
                        this.Invoke((Action)(() =>
                        {
                            btnCatch.Visible = false;
                        }));
                        Console.WriteLine("[DEBUG] Received HideCatchWindow, hiding Catch button on this client");
                    }
                    else if (msg.StartsWith("PlayerNames: "))
                    {
                        // Ví dụ msg = "PlayerNames: Alice|Bob|Charlie|David"
                        var parts = msg.Substring("PlayerNames: ".Length).Split('|');
                        if (parts.Length == 4)
                        {
                            // NameMe
                            NameMe.Invoke((Action)(() => NameMe.Text = parts[myPlayerId - 1]));
                            // 3 người còn lại, thứ tự là (myPlayerId % 4) + i
                            for (int i = 1; i <= 3; i++)
                            {
                                int idx = (myPlayerId - 1 + i) % 4;
                                var lbl = this.Controls[$"Name{i}"] as Label;
                                lbl?.Invoke((Action)(() => lbl.Text = parts[idx]));
                            }
                        }
                    }




                }


                //update draw pile and discard pile
                //else if (msg.StartsWith("Dataqueue: "))
                //{
                //    string[] parts = msg.Substring("Dataqueue: ".Length).Split('|');
                //    if (parts.Length == 2)
                //    {
                //        string[] dataQueue = parts[0].Split(',');
                //        string[] dataQueue1 = parts[1].Split(',');

                //        deck.Clear();
                //        foreach (string card in dataQueue)
                //        {
                //            deck.Add(card.Trim());
                //        }
                //        discardDeck.Clear();
                //        foreach (string card in dataQueue1)
                //        {
                //            discardDeck.Add(card.Trim());
                //        }
                //    }
                //}


            }
            catch (Exception ex)
            {
                // marshal error dialog
                this.Invoke((Action)(() =>
                    MessageBox.Show($"Error: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error)
                ));
            }
        }
        private async void ReadyBtn_Click(object sender, EventArgs e)
        {
            try
            {
                ReadyBtn.Visible = false;
                byte[] buffer = Encoding.UTF8.GetBytes($"Ready: {Room.Text.Trim()}");
                await stream.WriteAsync(buffer, 0, buffer.Length); // Gửi thông báo "Ready" đến server

            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }
        //helper check bài có thể đánh để ban draw 
        private bool HasPlayableCard()
        {
            return playerHand.Any(card => IsValidMove(card));
        }
        private void Room_TextChanged(object sender, EventArgs e)
        {

        }

        private void isPlay2_Click(object sender, EventArgs e)
        {

        }

        private void btnUno_Click(object sender, EventArgs e)
        {
            stream.Write(Encoding.UTF8.GetBytes($"UnoCall: {myPlayerId}\n"));
            unoCalled = true;
            btnUno.Visible = false;
            Console.WriteLine($"[DEBUG] Sent UnoCall for player {myPlayerId}");
        }

        private void btnCatch_Click(object sender, EventArgs e)
        {
            stream.Write(Encoding.UTF8.GetBytes($"CatchUno: {targetId}\n"));
            btnCatch.Visible = false;
            Console.WriteLine($"[DEBUG] Sent CatchUno for target {targetId}");
        }

        private void chatInput_TextChanged(object sender, EventArgs e)
        {

        }

        private void sendBtn_Click(object sender, EventArgs e)
        {
            string chatMsg = chatInput.Text.Trim();
            if (!chatMsg.IsNullOrEmpty())
            {
                stream.Write(Encoding.UTF8.GetBytes($"Chat: {chatMsg}\n"));
            }
            chatInput.Clear();
        }
        private void Arena_Load(object sender, EventArgs e)
        {

        }

        private void backBtn_Click(object sender, EventArgs e)
        {
            this.Hide();
            Menu Form1 = new Menu(playerName, TcpClient);
            Form1.Show();
        }

        private async void Arena_FormClosing(object sender, FormClosingEventArgs e)
        {
            try
            {
                Console.WriteLine("[DEBUG] Arena form is closing, handling disconnection...");

                // Send disconnect message to server
                if (stream != null && TcpClient != null && TcpClient.Connected)
                {
                    string disconnectMessage = $"Disconnect: {playerName}\n";
                    byte[] buffer = Encoding.UTF8.GetBytes(disconnectMessage);
                    await stream.WriteAsync(buffer, 0, buffer.Length);

                    // Close the connection
                    stream.Close();
                    TcpClient.Close();
                }

                Console.WriteLine("[DEBUG] Client disconnection handled successfully");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[ERROR] Error during form closing: {ex.Message}");
            }
        }

        private void Name3_Click(object sender, EventArgs e)
        {

        }
    }
}
```

### UNO\Arena.Designer.cs
```cs
﻿namespace UNO
{
    partial class Arena
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            MiddlePictureBox = new PictureBox();
            AvatarPlayer = new PictureBox();
            Enemy = new PictureBox();
            setting = new PictureBox();
            imojiButon = new PictureBox();
            ClockIcon = new PictureBox();
            clock1 = new PictureBox();
            TimeMe = new Label();
            DrawButton = new Button();
            Card1 = new PictureBox();
            Card2 = new PictureBox();
            Card3 = new PictureBox();
            Card4 = new PictureBox();
            Card5 = new PictureBox();
            PreviousButton = new Button();
            NextButton = new Button();
            SortButton = new Button();
            Card6 = new PictureBox();
            TimeEnemy = new Label();
            ReadyBtn = new Button();
            isPlay1 = new PictureBox();
            isPlay2 = new PictureBox();
            Room = new TextBox();
            isPlay3 = new PictureBox();
            isPlay4 = new PictureBox();
            sqlCommand1 = new Microsoft.Data.SqlClient.SqlCommand();
            sqlCommandBuilder1 = new Microsoft.Data.SqlClient.SqlCommandBuilder();
            sqlCommand2 = new Microsoft.Data.SqlClient.SqlCommand();
            sqlCommand3 = new Microsoft.Data.SqlClient.SqlCommand();
            sqlCommand4 = new Microsoft.Data.SqlClient.SqlCommand();
            sqlCommandBuilder2 = new Microsoft.Data.SqlClient.SqlCommandBuilder();
            btnUno = new Button();
            btnCatch = new Button();
            chatBox = new RichTextBox();
            chatInput = new TextBox();
            sendBtn = new Button();
            resultLabel = new Label();
            scoreLabel = new Label();
            backBtn = new Button();
            pictureBox1 = new PictureBox();
            pictureBox2 = new PictureBox();
            NameMe = new Label();
            Name1 = new Label();
            Name2 = new Label();
            Name3 = new Label();
            ((System.ComponentModel.ISupportInitialize)MiddlePictureBox).BeginInit();
            ((System.ComponentModel.ISupportInitialize)AvatarPlayer).BeginInit();
            ((System.ComponentModel.ISupportInitialize)Enemy).BeginInit();
            ((System.ComponentModel.ISupportInitialize)setting).BeginInit();
            ((System.ComponentModel.ISupportInitialize)imojiButon).BeginInit();
            ((System.ComponentModel.ISupportInitialize)ClockIcon).BeginInit();
            ((System.ComponentModel.ISupportInitialize)clock1).BeginInit();
            ((System.ComponentModel.ISupportInitialize)Card1).BeginInit();
            ((System.ComponentModel.ISupportInitialize)Card2).BeginInit();
            ((System.ComponentModel.ISupportInitialize)Card3).BeginInit();
            ((System.ComponentModel.ISupportInitialize)Card4).BeginInit();
            ((System.ComponentModel.ISupportInitialize)Card5).BeginInit();
            ((System.ComponentModel.ISupportInitialize)Card6).BeginInit();
            ((System.ComponentModel.ISupportInitialize)isPlay1).BeginInit();
            ((System.ComponentModel.ISupportInitialize)isPlay2).BeginInit();
            ((System.ComponentModel.ISupportInitialize)isPlay3).BeginInit();
            ((System.ComponentModel.ISupportInitialize)isPlay4).BeginInit();
            ((System.ComponentModel.ISupportInitialize)pictureBox1).BeginInit();
            ((System.ComponentModel.ISupportInitialize)pictureBox2).BeginInit();
            SuspendLayout();
            // 
            // MiddlePictureBox
            // 
            MiddlePictureBox.BackColor = Color.Transparent;
            MiddlePictureBox.Image = Properties.Resources.pngtree_uno_card_png_image_9101654;
            MiddlePictureBox.Location = new Point(398, 176);
            MiddlePictureBox.Name = "MiddlePictureBox";
            MiddlePictureBox.Size = new Size(88, 117);
            MiddlePictureBox.SizeMode = PictureBoxSizeMode.StretchImage;
            MiddlePictureBox.TabIndex = 0;
            MiddlePictureBox.TabStop = false;
            MiddlePictureBox.Visible = false;
            MiddlePictureBox.Click += drawCard_Click;
            // 
            // AvatarPlayer
            // 
            AvatarPlayer.BackgroundImage = Properties.Resources.uno_card_red_poster_fahn507dk0y40lko;
            AvatarPlayer.Cursor = Cursors.Hand;
            AvatarPlayer.Image = Properties.Resources.avatar_removebg_preview;
            AvatarPlayer.Location = new Point(71, 419);
            AvatarPlayer.Name = "AvatarPlayer";
            AvatarPlayer.Size = new Size(80, 80);
            AvatarPlayer.SizeMode = PictureBoxSizeMode.StretchImage;
            AvatarPlayer.TabIndex = 1;
            AvatarPlayer.TabStop = false;
            AvatarPlayer.Visible = false;
            AvatarPlayer.Click += AvatarPlayer_Click;
            // 
            // Enemy
            // 
            Enemy.BackColor = Color.Transparent;
            Enemy.Cursor = Cursors.Hand;
            Enemy.Image = Properties.Resources.avatar_removebg_preview;
            Enemy.Location = new Point(491, 18);
            Enemy.Name = "Enemy";
            Enemy.Size = new Size(80, 80);
            Enemy.SizeMode = PictureBoxSizeMode.StretchImage;
            Enemy.TabIndex = 2;
            Enemy.TabStop = false;
            Enemy.Visible = false;
            Enemy.Click += Enemy_Click;
            // 
            // setting
            // 
            setting.BackColor = Color.Transparent;
            setting.Image = Properties.Resources.light_blue_settings_gear_22453__1_;
            setting.Location = new Point(9, 12);
            setting.Name = "setting";
            setting.Size = new Size(47, 47);
            setting.SizeMode = PictureBoxSizeMode.Zoom;
            setting.TabIndex = 3;
            setting.TabStop = false;
            setting.Visible = false;
            setting.Click += setting_Click_1;
            // 
            // imojiButon
            // 
            imojiButon.BackColor = Color.Transparent;
            imojiButon.Image = Properties.Resources._19822c18e912ad0ffb2ad2faed8a61af__1__removebg_preview1;
            imojiButon.Location = new Point(9, 440);
            imojiButon.Name = "imojiButon";
            imojiButon.Size = new Size(56, 51);
            imojiButon.SizeMode = PictureBoxSizeMode.StretchImage;
            imojiButon.TabIndex = 4;
            imojiButon.TabStop = false;
            imojiButon.Visible = false;
            imojiButon.Click += pictureBox1_Click;
            // 
            // ClockIcon
            // 
            ClockIcon.BackColor = Color.Transparent;
            ClockIcon.Image = Properties.Resources.clock_removebg_preview;
            ClockIcon.Location = new Point(729, 440);
            ClockIcon.Name = "ClockIcon";
            ClockIcon.Size = new Size(66, 59);
            ClockIcon.SizeMode = PictureBoxSizeMode.StretchImage;
            ClockIcon.TabIndex = 5;
            ClockIcon.TabStop = false;
            ClockIcon.Visible = false;
            // 
            // clock1
            // 
            clock1.BackColor = Color.Transparent;
            clock1.Image = Properties.Resources.clock_removebg_preview;
            clock1.Location = new Point(62, 3);
            clock1.Name = "clock1";
            clock1.Size = new Size(66, 59);
            clock1.SizeMode = PictureBoxSizeMode.StretchImage;
            clock1.TabIndex = 6;
            clock1.TabStop = false;
            clock1.Visible = false;
            // 
            // TimeMe
            // 
            TimeMe.BackColor = Color.Transparent;
            TimeMe.Font = new Font("Segoe UI", 21.75F, FontStyle.Regular, GraphicsUnit.Point, 0);
            TimeMe.Location = new Point(802, 440);
            TimeMe.Name = "TimeMe";
            TimeMe.Size = new Size(59, 59);
            TimeMe.TabIndex = 7;
            TimeMe.Text = "10";
            TimeMe.TextAlign = ContentAlignment.MiddleCenter;
            TimeMe.Visible = false;
            TimeMe.Click += label1_Click;
            // 
            // DrawButton
            // 
            DrawButton.Cursor = Cursors.Hand;
            DrawButton.Location = new Point(786, 229);
            DrawButton.Name = "DrawButton";
            DrawButton.Size = new Size(75, 36);
            DrawButton.TabIndex = 8;
            DrawButton.Text = "Draw";
            DrawButton.UseVisualStyleBackColor = true;
            DrawButton.Visible = false;
            DrawButton.Click += button1_Click;
            // 
            // Card1
            // 
            Card1.BackColor = Color.Transparent;
            Card1.Cursor = Cursors.Hand;
            Card1.Image = Properties.Resources.pngtree_uno_card_png_image_9101654;
            Card1.Location = new Point(157, 373);
            Card1.Name = "Card1";
            Card1.Size = new Size(88, 117);
            Card1.SizeMode = PictureBoxSizeMode.Zoom;
            Card1.TabIndex = 9;
            Card1.TabStop = false;
            Card1.Visible = false;
            Card1.Click += Card1_Click;
            // 
            // Card2
            // 
            Card2.BackColor = Color.Transparent;
            Card2.Cursor = Cursors.Hand;
            Card2.Image = Properties.Resources.pngtree_uno_card_png_image_9101654;
            Card2.Location = new Point(249, 373);
            Card2.Name = "Card2";
            Card2.Size = new Size(88, 117);
            Card2.SizeMode = PictureBoxSizeMode.Zoom;
            Card2.TabIndex = 10;
            Card2.TabStop = false;
            Card2.Visible = false;
            Card2.Click += Card2_Click;
            // 
            // Card3
            // 
            Card3.BackColor = Color.Transparent;
            Card3.Cursor = Cursors.Hand;
            Card3.Image = Properties.Resources.pngtree_uno_card_png_image_9101654;
            Card3.Location = new Point(341, 373);
            Card3.Name = "Card3";
            Card3.Size = new Size(88, 117);
            Card3.SizeMode = PictureBoxSizeMode.Zoom;
            Card3.TabIndex = 10;
            Card3.TabStop = false;
            Card3.Visible = false;
            // 
            // Card4
            // 
            Card4.BackColor = Color.Transparent;
            Card4.Cursor = Cursors.Hand;
            Card4.Image = Properties.Resources.pngtree_uno_card_png_image_9101654;
            Card4.Location = new Point(434, 373);
            Card4.Name = "Card4";
            Card4.Size = new Size(88, 117);
            Card4.SizeMode = PictureBoxSizeMode.Zoom;
            Card4.TabIndex = 11;
            Card4.TabStop = false;
            Card4.Visible = false;
            // 
            // Card5
            // 
            Card5.BackColor = Color.Transparent;
            Card5.Cursor = Cursors.Hand;
            Card5.Image = Properties.Resources.pngtree_uno_card_png_image_9101654;
            Card5.Location = new Point(528, 373);
            Card5.Name = "Card5";
            Card5.Size = new Size(88, 117);
            Card5.SizeMode = PictureBoxSizeMode.Zoom;
            Card5.TabIndex = 12;
            Card5.TabStop = false;
            Card5.Visible = false;
            Card5.Click += Card5_Click;
            // 
            // PreviousButton
            // 
            PreviousButton.Cursor = Cursors.Hand;
            PreviousButton.Location = new Point(101, 367);
            PreviousButton.Name = "PreviousButton";
            PreviousButton.Size = new Size(37, 29);
            PreviousButton.TabIndex = 13;
            PreviousButton.Text = "<";
            PreviousButton.UseVisualStyleBackColor = true;
            PreviousButton.Visible = false;
            PreviousButton.Click += PreviousButton_Click;
            // 
            // NextButton
            // 
            NextButton.Cursor = Cursors.Hand;
            NextButton.Location = new Point(729, 367);
            NextButton.Name = "NextButton";
            NextButton.Size = new Size(37, 29);
            NextButton.TabIndex = 14;
            NextButton.Text = ">";
            NextButton.UseVisualStyleBackColor = true;
            NextButton.Visible = false;
            NextButton.Click += NextButton_Click;
            // 
            // SortButton
            // 
            SortButton.Cursor = Cursors.Hand;
            SortButton.Location = new Point(9, 367);
            SortButton.Name = "SortButton";
            SortButton.Size = new Size(75, 36);
            SortButton.TabIndex = 20;
            SortButton.Text = "Sort";
            SortButton.UseVisualStyleBackColor = true;
            SortButton.Visible = false;
            SortButton.Click += SortButton_Click;
            // 
            // Card6
            // 
            Card6.BackColor = Color.Transparent;
            Card6.Cursor = Cursors.Hand;
            Card6.Image = Properties.Resources.pngtree_uno_card_png_image_9101654;
            Card6.Location = new Point(622, 373);
            Card6.Name = "Card6";
            Card6.Size = new Size(88, 117);
            Card6.SizeMode = PictureBoxSizeMode.Zoom;
            Card6.TabIndex = 21;
            Card6.TabStop = false;
            Card6.Visible = false;
            Card6.Click += Card6_Click;
            // 
            // TimeEnemy
            // 
            TimeEnemy.BackColor = Color.Transparent;
            TimeEnemy.Font = new Font("Segoe UI", 21.75F, FontStyle.Regular, GraphicsUnit.Point, 0);
            TimeEnemy.Location = new Point(134, 0);
            TimeEnemy.Name = "TimeEnemy";
            TimeEnemy.Size = new Size(59, 59);
            TimeEnemy.TabIndex = 22;
            TimeEnemy.Text = "10";
            TimeEnemy.TextAlign = ContentAlignment.MiddleCenter;
            TimeEnemy.Visible = false;
            // 
            // ReadyBtn
            // 
            ReadyBtn.Cursor = Cursors.Hand;
            ReadyBtn.Location = new Point(786, 367);
            ReadyBtn.Name = "ReadyBtn";
            ReadyBtn.Size = new Size(75, 36);
            ReadyBtn.TabIndex = 23;
            ReadyBtn.Text = "Ready";
            ReadyBtn.UseVisualStyleBackColor = true;
            ReadyBtn.Click += ReadyBtn_Click;
            // 
            // isPlay1
            // 
            isPlay1.BackColor = SystemColors.Control;
            isPlay1.Cursor = Cursors.Hand;
            isPlay1.Image = Properties.Resources.pngtree_uno_card_png_image_9101654;
            isPlay1.Location = new Point(71, 176);
            isPlay1.Name = "isPlay1";
            isPlay1.Size = new Size(109, 167);
            isPlay1.SizeMode = PictureBoxSizeMode.Zoom;
            isPlay1.TabIndex = 24;
            isPlay1.TabStop = false;
            // 
            // isPlay2
            // 
            isPlay2.BackColor = SystemColors.Control;
            isPlay2.Cursor = Cursors.Hand;
            isPlay2.Image = Properties.Resources.pngtree_uno_card_png_image_9101654;
            isPlay2.Location = new Point(279, 176);
            isPlay2.Name = "isPlay2";
            isPlay2.Size = new Size(112, 167);
            isPlay2.SizeMode = PictureBoxSizeMode.Zoom;
            isPlay2.TabIndex = 25;
            isPlay2.TabStop = false;
            isPlay2.Click += isPlay2_Click;
            // 
            // Room
            // 
            Room.Location = new Point(9, 68);
            Room.Margin = new Padding(3, 4, 3, 4);
            Room.Name = "Room";
            Room.Size = new Size(114, 27);
            Room.TabIndex = 26;
            Room.Text = "Room";
            Room.TextChanged += Room_TextChanged;
            // 
            // isPlay3
            // 
            isPlay3.BackColor = SystemColors.Control;
            isPlay3.Cursor = Cursors.Hand;
            isPlay3.Image = Properties.Resources.pngtree_uno_card_png_image_9101654;
            isPlay3.Location = new Point(504, 176);
            isPlay3.Name = "isPlay3";
            isPlay3.Size = new Size(112, 167);
            isPlay3.SizeMode = PictureBoxSizeMode.Zoom;
            isPlay3.TabIndex = 27;
            isPlay3.TabStop = false;
            // 
            // isPlay4
            // 
            isPlay4.BackColor = SystemColors.Control;
            isPlay4.Cursor = Cursors.Hand;
            isPlay4.Image = Properties.Resources.pngtree_uno_card_png_image_9101654;
            isPlay4.Location = new Point(697, 176);
            isPlay4.Name = "isPlay4";
            isPlay4.Size = new Size(112, 167);
            isPlay4.SizeMode = PictureBoxSizeMode.Zoom;
            isPlay4.TabIndex = 28;
            isPlay4.TabStop = false;
            // 
            // sqlCommand1
            // 
            sqlCommand1.CommandTimeout = 30;
            sqlCommand1.EnableOptimizedParameterBinding = false;
            // 
            // sqlCommand2
            // 
            sqlCommand2.CommandTimeout = 30;
            sqlCommand2.EnableOptimizedParameterBinding = false;
            // 
            // sqlCommand3
            // 
            sqlCommand3.CommandTimeout = 30;
            sqlCommand3.EnableOptimizedParameterBinding = false;
            // 
            // sqlCommand4
            // 
            sqlCommand4.CommandTimeout = 30;
            sqlCommand4.EnableOptimizedParameterBinding = false;
            // 
            // btnUno
            // 
            btnUno.Location = new Point(622, 229);
            btnUno.Name = "btnUno";
            btnUno.Size = new Size(69, 36);
            btnUno.TabIndex = 29;
            btnUno.Text = "UNO!";
            btnUno.UseVisualStyleBackColor = true;
            btnUno.Click += btnUno_Click;
            // 
            // btnCatch
            // 
            btnCatch.Location = new Point(622, 271);
            btnCatch.Name = "btnCatch";
            btnCatch.Size = new Size(69, 35);
            btnCatch.TabIndex = 30;
            btnCatch.Text = "Catch";
            btnCatch.UseVisualStyleBackColor = true;
            btnCatch.Click += btnCatch_Click;
            // 
            // chatBox
            // 
            chatBox.Location = new Point(9, 101);
            chatBox.Name = "chatBox";
            chatBox.Size = new Size(185, 191);
            chatBox.TabIndex = 31;
            chatBox.Text = "";
            // 
            // chatInput
            // 
            chatInput.Location = new Point(9, 299);
            chatInput.Name = "chatInput";
            chatInput.Size = new Size(185, 27);
            chatInput.TabIndex = 32;
            chatInput.TextChanged += chatInput_TextChanged;
            // 
            // sendBtn
            // 
            sendBtn.Location = new Point(9, 332);
            sendBtn.Name = "sendBtn";
            sendBtn.Size = new Size(94, 29);
            sendBtn.TabIndex = 33;
            sendBtn.Text = "Send";
            sendBtn.UseVisualStyleBackColor = true;
            sendBtn.Click += sendBtn_Click;
            // 
            // resultLabel
            // 
            resultLabel.AutoSize = true;
            resultLabel.BackColor = Color.Transparent;
            resultLabel.Font = new Font("Segoe UI", 19.8000011F, FontStyle.Bold | FontStyle.Italic, GraphicsUnit.Point, 0);
            resultLabel.ForeColor = SystemColors.Window;
            resultLabel.Location = new Point(341, 16);
            resultLabel.Name = "resultLabel";
            resultLabel.Size = new Size(164, 46);
            resultLabel.TabIndex = 34;
            resultLabel.Text = "KẾT QUẢ";
            resultLabel.Visible = false;
            // 
            // scoreLabel
            // 
            scoreLabel.AutoSize = true;
            scoreLabel.BackColor = Color.Transparent;
            scoreLabel.Font = new Font("Segoe UI", 13.2000008F, FontStyle.Italic, GraphicsUnit.Point, 0);
            scoreLabel.ForeColor = SystemColors.Window;
            scoreLabel.Location = new Point(279, 101);
            scoreLabel.Name = "scoreLabel";
            scoreLabel.Size = new Size(280, 31);
            scoreLabel.TabIndex = 35;
            scoreLabel.Text = "Điểm chiến thắng hiện tại: ";
            scoreLabel.Visible = false;
            // 
            // backBtn
            // 
            backBtn.BackColor = Color.LimeGreen;
            backBtn.Font = new Font("Segoe UI", 15F, FontStyle.Bold, GraphicsUnit.Point, 0);
            backBtn.ForeColor = SystemColors.ButtonHighlight;
            backBtn.Location = new Point(358, 263);
            backBtn.Name = "backBtn";
            backBtn.Size = new Size(181, 80);
            backBtn.TabIndex = 36;
            backBtn.Text = "BACK";
            backBtn.UseVisualStyleBackColor = false;
            backBtn.Visible = false;
            backBtn.Click += backBtn_Click;
            // 
            // pictureBox1
            // 
            pictureBox1.BackColor = Color.Transparent;
            pictureBox1.Cursor = Cursors.Hand;
            pictureBox1.Image = Properties.Resources.avatar_removebg_preview;
            pictureBox1.Location = new Point(193, 143);
            pictureBox1.Name = "pictureBox1";
            pictureBox1.Size = new Size(80, 80);
            pictureBox1.SizeMode = PictureBoxSizeMode.StretchImage;
            pictureBox1.TabIndex = 37;
            pictureBox1.TabStop = false;
            pictureBox1.Visible = false;
            // 
            // pictureBox2
            // 
            pictureBox2.BackColor = Color.Transparent;
            pictureBox2.Cursor = Cursors.Hand;
            pictureBox2.Image = Properties.Resources.avatar_removebg_preview;
            pictureBox2.Location = new Point(763, 143);
            pictureBox2.Name = "pictureBox2";
            pictureBox2.Size = new Size(80, 80);
            pictureBox2.SizeMode = PictureBoxSizeMode.StretchImage;
            pictureBox2.TabIndex = 38;
            pictureBox2.TabStop = false;
            pictureBox2.Visible = false;
            // 
            // NameMe
            // 
            NameMe.AutoSize = true;
            NameMe.Location = new Point(88, 399);
            NameMe.Name = "NameMe";
            NameMe.Size = new Size(50, 20);
            NameMe.TabIndex = 39;
            NameMe.Text = "label1";
            // 
            // Name1
            // 
            Name1.AutoSize = true;
            Name1.Location = new Point(776, 120);
            Name1.Name = "Name1";
            Name1.Size = new Size(50, 20);
            Name1.TabIndex = 40;
            Name1.Text = "label1";
            // 
            // Name2
            // 
            Name2.AutoSize = true;
            Name2.Location = new Point(509, 0);
            Name2.Name = "Name2";
            Name2.Size = new Size(50, 20);
            Name2.TabIndex = 41;
            Name2.Text = "label1";
            // 
            // Name3
            // 
            Name3.AutoSize = true;
            Name3.Location = new Point(210, 120);
            Name3.Name = "Name3";
            Name3.Size = new Size(50, 20);
            Name3.TabIndex = 42;
            Name3.Text = "label1";
            Name3.Click += Name3_Click;
            // 
            // Arena
            // 
            AutoScaleDimensions = new SizeF(8F, 20F);
            AutoScaleMode = AutoScaleMode.Font;
            BackgroundImage = Properties.Resources.uno_card_red_poster_fahn507dk0y40lko;
            BackgroundImageLayout = ImageLayout.Stretch;
            ClientSize = new Size(875, 511);
            Controls.Add(Name3);
            Controls.Add(Name2);
            Controls.Add(Name1);
            Controls.Add(NameMe);
            Controls.Add(pictureBox2);
            Controls.Add(pictureBox1);
            Controls.Add(backBtn);
            Controls.Add(scoreLabel);
            Controls.Add(resultLabel);
            Controls.Add(sendBtn);
            Controls.Add(chatInput);
            Controls.Add(chatBox);
            Controls.Add(btnCatch);
            Controls.Add(btnUno);
            Controls.Add(isPlay4);
            Controls.Add(isPlay3);
            Controls.Add(Room);
            Controls.Add(isPlay2);
            Controls.Add(isPlay1);
            Controls.Add(ReadyBtn);
            Controls.Add(TimeEnemy);
            Controls.Add(Card6);
            Controls.Add(SortButton);
            Controls.Add(NextButton);
            Controls.Add(PreviousButton);
            Controls.Add(Card5);
            Controls.Add(Card4);
            Controls.Add(Card3);
            Controls.Add(Card2);
            Controls.Add(Card1);
            Controls.Add(DrawButton);
            Controls.Add(TimeMe);
            Controls.Add(clock1);
            Controls.Add(ClockIcon);
            Controls.Add(imojiButon);
            Controls.Add(setting);
            Controls.Add(Enemy);
            Controls.Add(AvatarPlayer);
            Controls.Add(MiddlePictureBox);
            FormBorderStyle = FormBorderStyle.Fixed3D;
            MaximizeBox = false;
            Name = "Arena";
            Text = "Arena";
            Load += Arena_Load;
            ((System.ComponentModel.ISupportInitialize)MiddlePictureBox).EndInit();
            ((System.ComponentModel.ISupportInitialize)AvatarPlayer).EndInit();
            ((System.ComponentModel.ISupportInitialize)Enemy).EndInit();
            ((System.ComponentModel.ISupportInitialize)setting).EndInit();
            ((System.ComponentModel.ISupportInitialize)imojiButon).EndInit();
            ((System.ComponentModel.ISupportInitialize)ClockIcon).EndInit();
            ((System.ComponentModel.ISupportInitialize)clock1).EndInit();
            ((System.ComponentModel.ISupportInitialize)Card1).EndInit();
            ((System.ComponentModel.ISupportInitialize)Card2).EndInit();
            ((System.ComponentModel.ISupportInitialize)Card3).EndInit();
            ((System.ComponentModel.ISupportInitialize)Card4).EndInit();
            ((System.ComponentModel.ISupportInitialize)Card5).EndInit();
            ((System.ComponentModel.ISupportInitialize)Card6).EndInit();
            ((System.ComponentModel.ISupportInitialize)isPlay1).EndInit();
            ((System.ComponentModel.ISupportInitialize)isPlay2).EndInit();
            ((System.ComponentModel.ISupportInitialize)isPlay3).EndInit();
            ((System.ComponentModel.ISupportInitialize)isPlay4).EndInit();
            ((System.ComponentModel.ISupportInitialize)pictureBox1).EndInit();
            ((System.ComponentModel.ISupportInitialize)pictureBox2).EndInit();
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private PictureBox MiddlePictureBox;
        private PictureBox AvatarPlayer;
        private PictureBox Enemy;
        private PictureBox setting;
        private PictureBox imojiButon;
        private PictureBox ClockIcon;
        private PictureBox clock1;
        private Label TimeMe;
        private Button DrawButton;
        private PictureBox Card1;
        private PictureBox Card2;
        private PictureBox Card3;
        private PictureBox Card4;
        private PictureBox Card5;
        private Button PreviousButton;
        private Button NextButton;
        private Button SortButton;
        private PictureBox Card6;
        private Label TimeEnemy;
        private Button ReadyBtn;
        private PictureBox isPlay1;
        private PictureBox isPlay2;
        private TextBox Room;
        private PictureBox isPlay3;
        private PictureBox isPlay4;
        private Microsoft.Data.SqlClient.SqlCommand sqlCommand1;
        private Microsoft.Data.SqlClient.SqlCommandBuilder sqlCommandBuilder1;
        private Microsoft.Data.SqlClient.SqlCommand sqlCommand2;
        private Microsoft.Data.SqlClient.SqlCommand sqlCommand3;
        private Microsoft.Data.SqlClient.SqlCommand sqlCommand4;
        private Microsoft.Data.SqlClient.SqlCommandBuilder sqlCommandBuilder2;
        private Button btnUno;
        private Button btnCatch;
        private RichTextBox chatBox;
        private TextBox chatInput;
        private Button sendBtn;
        private Label resultLabel;
        private Label scoreLabel;
        private Button backBtn;
        private PictureBox pictureBox1;
        private PictureBox pictureBox2;
        private Label NameMe;
        private Label Name1;
        private Label Name2;
        private Label Name3;
    }
}
```

### UNO\Login.cs
```cs
﻿using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using static System.Windows.Forms.VisualStyles.VisualStyleElement.StartPanel;

namespace UNO
{
    public partial class Login : Form
    {
        public TcpClient player;
        public Login()
        {
            InitializeComponent();
            this.FormClosing += Login_FormClosing;
        }

        private async Task ConnectServer()
        {
            try
            {
                player = new TcpClient();
                IPAddress serverIP = IPAddress.Parse("127.0.0.1"); //server IP
                player.Connect(serverIP, 10000);

                //sau khi đã kết nối thì lấy stream để thông báo cho server rằng người dùng đã kết nối
                NetworkStream stream = player.GetStream();
                byte[] buffer = Encoding.UTF8.GetBytes($"Player: {textBox1.Text.Trim()}|{password.Text.Trim()}\n");
                stream.Write(buffer, 0, buffer.Length);
               



                // Đọc phản hồi từ server
                using var reader = new StreamReader(stream, Encoding.UTF8,leaveOpen:true);
                string response = await reader.ReadLineAsync();
                if (response.StartsWith("LoginOK: "))
                {
                  
                    // Mở form
                    this.Hide();
                    Menu Form1 = new Menu(textBox1.Text.Trim(), player);
                    Form1.Show();
                }

                else
                if (response.StartsWith("LoginFail: "))
                {
                    string reason = response.Substring("LoginFail: ".Length);
                    string message = reason switch
                    {


                        "WrongPassword" => "Mật khẩu không đúng.", // Giữ lại nếu bạn có cách khác để xử lí mật khẩu
                        "AlreadyOnline" => "Tài khoản đang được sử dụng.",
                        "UserAlreadyExists" => "Tài khoản đã tồn tại. Vui lòng đăng nhập hoặc dùng email/tên người dùng khác.",
                        "RegistrationFailed" => "Đăng ký thất bại. Vui lòng thử lại.",
                        "DatabaseSaveError" => "Lỗi lưu dữ liệu. Vui lòng thử lại.",
                        "InvalidFormat" => "Lỗi định dạng yêu cầu.",
                        "MissingCredentials" => "Vui lòng nhập đầy đủ tên người dùng và mật khẩu.",
                        "InternalServerError" => "Lỗi server nội bộ. Vui lòng thử lại sau.",
                        "MessageParseError" => "Lỗi xử lý tin nhắn từ server.",
                        _ => "Đăng nhập thất bại không xác định."
                    };

                    MessageBox.Show(message, "Lỗi đăng nhập", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }

                

                //this.Close();
            }
            catch (Exception ex) 
            {
                MessageBox.Show("Error: " +  ex.Message);
            }
        }

        private async void loginBtn_Click(object sender, EventArgs e)
        {
            if (textBox1.Text.Trim() == "")
            {
                return;
            }

            //trước hết là xử lí xem đã có người dùng hay chưa, mà chưa có CSDL nên để sau
            await ConnectServer();

        }

        private async void Login_FormClosing(object sender, FormClosingEventArgs e)
        {
            try
            {
                Console.WriteLine("[DEBUG] Login form is closing, handling disconnection...");
                
                // Send disconnect message to server if connected
                if (player != null && player.Connected)
                {
                    NetworkStream stream = player.GetStream();
                    string disconnectMessage = $"Disconnect: {textBox1.Text.Trim()}\n";
                    byte[] buffer = Encoding.UTF8.GetBytes(disconnectMessage);
                    stream.Write(buffer, 0, buffer.Length);
                    
                    // Close the connection
                    stream.Close();
                    player.Close();
                }
                
                Console.WriteLine("[DEBUG] Login form disconnection handled successfully");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[ERROR] Error during login form closing: {ex.Message}");
            }
        }
    }
}

```

### UNO\Login.Designer.cs
```cs
﻿namespace UNO
{
    partial class Login
    {
        /// <summary>
        ///  Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        ///  Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        ///  Required method for Designer support - do not modify
        ///  the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            userLabel = new Label();
            loginBtn = new Button();
            textBox1 = new TextBox();
            label1 = new Label();
            password = new TextBox();
            label2 = new Label();
            SuspendLayout();
            // 
            // userLabel
            // 
            userLabel.AutoSize = true;
            userLabel.BackColor = Color.Transparent;
            userLabel.Font = new Font("Segoe UI Semibold", 9F, FontStyle.Bold | FontStyle.Italic, GraphicsUnit.Point, 0);
            userLabel.ForeColor = Color.DimGray;
            userLabel.Location = new Point(338, 151);
            userLabel.Name = "userLabel";
            userLabel.Size = new Size(62, 15);
            userLabel.TabIndex = 1;
            userLabel.Text = "Username";
            // 
            // loginBtn
            // 
            loginBtn.BackColor = Color.LimeGreen;
            loginBtn.Font = new Font("Segoe UI Semibold", 15F, FontStyle.Bold, GraphicsUnit.Point, 0);
            loginBtn.ForeColor = SystemColors.ButtonHighlight;
            loginBtn.Location = new Point(338, 253);
            loginBtn.Name = "loginBtn";
            loginBtn.Size = new Size(125, 55);
            loginBtn.TabIndex = 0;
            loginBtn.Text = "Login";
            loginBtn.UseVisualStyleBackColor = false;
            loginBtn.Click += loginBtn_Click;
            // 
            // textBox1
            // 
            textBox1.Location = new Point(338, 174);
            textBox1.Name = "textBox1";
            textBox1.Size = new Size(125, 23);
            textBox1.TabIndex = 4;
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.BackColor = Color.Transparent;
            label1.Font = new Font("Segoe UI Semibold", 19.8000011F, FontStyle.Bold | FontStyle.Italic, GraphicsUnit.Point, 0);
            label1.ForeColor = SystemColors.Window;
            label1.Location = new Point(338, 47);
            label1.Name = "label1";
            label1.Size = new Size(98, 37);
            label1.TabIndex = 5;
            label1.Text = "LOGIN";
            // 
            // password
            // 
            password.Location = new Point(338, 218);
            password.Name = "password";
            password.Size = new Size(125, 23);
            password.TabIndex = 6;
            // 
            // label2
            // 
            label2.AutoSize = true;
            label2.BackColor = Color.Transparent;
            label2.Font = new Font("Segoe UI Semibold", 9F, FontStyle.Bold | FontStyle.Italic, GraphicsUnit.Point, 0);
            label2.ForeColor = Color.DimGray;
            label2.Location = new Point(338, 200);
            label2.Name = "label2";
            label2.Size = new Size(59, 15);
            label2.TabIndex = 7;
            label2.Text = "Password";
            // 
            // Login
            // 
            BackgroundImage = Properties.Resources.login;
            BackgroundImageLayout = ImageLayout.Zoom;
            ClientSize = new Size(800, 450);
            Controls.Add(label2);
            Controls.Add(password);
            Controls.Add(label1);
            Controls.Add(textBox1);
            Controls.Add(userLabel);
            Controls.Add(loginBtn);
            DoubleBuffered = true;
            FormBorderStyle = FormBorderStyle.Fixed3D;
            Name = "Login";
            Text = "Login";
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion
        private Label userLabel;
        private Button loginBtn;
        private TextBox textBox1;
        private Label label1;
        private TextBox password;
        private Label label2;
    }
}

```

### UNO\Menu.cs
```cs
﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace UNO
{
    public partial class Menu : Form
    {
        private string? username;
        private TcpClient? tcpPlayer;
        public Menu()
        {
            InitializeComponent();
        }

        public Menu(string playerName, TcpClient playerSocket)
        {
            InitializeComponent();
            username = playerName;
            tcpPlayer = playerSocket;
            
            // Add form closing event handler
            this.FormClosing += Menu_FormClosing;
            
            // Add click event handler for Thoát button
            button3.Click += ThoatButton_Click;
        }

        //vào một phòng mới với nút này
        private void button1_Click(object sender, EventArgs e)
        {
            try
            {
                //Gửi server yêu cầu vào phòng với format: "Play now: {username}"
                NetworkStream stream = tcpPlayer.GetStream();
                byte[] buffer = Encoding.UTF8.GetBytes($"Play now: {username}");
                stream.Write(buffer, 0, buffer.Length);

                //đợi server thêm vào phòng mới để vào arena
                while (tcpPlayer.Connected)
                {
                    if (tcpPlayer == null || !tcpPlayer.Connected)
                    {
                        MessageBox.Show("Not connected to server. Please reconnect.");
                        return;
                    }

                    byte[] bufferReceive = new byte[1024];
                    int byteCount = stream.Read(bufferReceive, 0, buffer.Length);
                    if (byteCount > 0)
                    {
                        string message = Encoding.UTF8.GetString(bufferReceive);
                        if (message.StartsWith("Room: "))
                        {
                            MessageBox.Show($"Success added to new room: {message.Substring(6).Trim()}");
                            Arena form1 = new Arena(username, tcpPlayer, message.Substring(6).Trim());
                            this.Hide();
                            form1.Show();                        
                            break;
                        }
                    }
                }
                //this.Close();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error: {ex.Message}");
            }  
        }

        private async void Menu_FormClosing(object sender, FormClosingEventArgs e)
        {
            try
            {
                Console.WriteLine("[DEBUG] Menu form is closing, handling disconnection...");
                
                // Send disconnect message to server
                if (tcpPlayer != null && tcpPlayer.Connected)
                {
                    NetworkStream stream = tcpPlayer.GetStream();
                    string disconnectMessage = $"Disconnect: {username}\n";
                    byte[] buffer = Encoding.UTF8.GetBytes(disconnectMessage);
                    await stream.WriteAsync(buffer, 0, buffer.Length);
                    
                    // Close the connection
                    stream.Close();
                    tcpPlayer.Close();
                }
                
                Console.WriteLine("[DEBUG] Menu form disconnection handled successfully");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[ERROR] Error during menu form closing: {ex.Message}");
            }
        }

        private async void ThoatButton_Click(object sender, EventArgs e)
        {
            try
            {
                Console.WriteLine("[DEBUG] Thoát button clicked, handling disconnection...");
                
                // Send disconnect message to server
                if (tcpPlayer != null && tcpPlayer.Connected)
                {
                    NetworkStream stream = tcpPlayer.GetStream();
                    string disconnectMessage = $"Disconnect: {username}\n";
                    byte[] buffer = Encoding.UTF8.GetBytes(disconnectMessage);
                    await stream.WriteAsync(buffer, 0, buffer.Length);
                    
                    // Close the connection
                    stream.Close();
                    tcpPlayer.Close();
                }
                
                Console.WriteLine("[DEBUG] Thoát button disconnection handled successfully");
                
                // Close the form
                this.Close();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[ERROR] Error during Thoát button click: {ex.Message}");
                MessageBox.Show($"Error during logout: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }
    }
}

```

### UNO\Menu.Designer.cs
```cs
﻿namespace UNO
{
    partial class Menu
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            button1 = new Button();
            button2 = new Button();
            button3 = new Button();
            label1 = new Label();
            SuspendLayout();
            // 
            // button1
            // 
            button1.BackColor = Color.LimeGreen;
            button1.Font = new Font("Segoe UI Semibold", 15F, FontStyle.Bold | FontStyle.Italic, GraphicsUnit.Point, 0);
            button1.ForeColor = SystemColors.HighlightText;
            button1.Location = new Point(301, 125);
            button1.Name = "button1";
            button1.Size = new Size(187, 56);
            button1.TabIndex = 0;
            button1.Text = "Chơi ngay";
            button1.UseVisualStyleBackColor = false;
            button1.Click += button1_Click;
            // 
            // button2
            // 
            button2.BackColor = Color.LimeGreen;
            button2.Font = new Font("Segoe UI Semibold", 15F, FontStyle.Bold | FontStyle.Italic, GraphicsUnit.Point, 0);
            button2.ForeColor = SystemColors.HighlightText;
            button2.Location = new Point(301, 209);
            button2.Name = "button2";
            button2.Size = new Size(187, 56);
            button2.TabIndex = 1;
            button2.Text = "Hướng dẫn";
            button2.UseVisualStyleBackColor = false;
            // 
            // button3
            // 
            button3.BackColor = Color.LimeGreen;
            button3.Font = new Font("Segoe UI Semibold", 15F, FontStyle.Bold | FontStyle.Italic, GraphicsUnit.Point, 0);
            button3.ForeColor = SystemColors.HighlightText;
            button3.Location = new Point(301, 293);
            button3.Name = "button3";
            button3.Size = new Size(187, 56);
            button3.TabIndex = 3;
            button3.Text = "Thoát";
            button3.UseVisualStyleBackColor = false;
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.BackColor = Color.Transparent;
            label1.Font = new Font("Segoe UI Semibold", 19.8000011F, FontStyle.Bold | FontStyle.Italic, GraphicsUnit.Point, 0);
            label1.ForeColor = SystemColors.ButtonHighlight;
            label1.Location = new Point(346, 29);
            label1.Name = "label1";
            label1.Size = new Size(96, 46);
            label1.TabIndex = 4;
            label1.Text = "UNO";
            // 
            // Menu
            // 
            AutoScaleDimensions = new SizeF(8F, 20F);
            AutoScaleMode = AutoScaleMode.Font;
            BackgroundImage = Properties.Resources.menu;
            BackgroundImageLayout = ImageLayout.Stretch;
            ClientSize = new Size(800, 451);
            Controls.Add(label1);
            Controls.Add(button3);
            Controls.Add(button2);
            Controls.Add(button1);
            FormBorderStyle = FormBorderStyle.Fixed3D;
            Name = "Menu";
            Text = "UNO";
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private Button button1;
        private Button button2;
        private Button button3;
        private Label label1;
    }
}
```

### UNO\Program.cs
```cs
namespace UNO
{
    internal static class Program
    {
        /// <summary>
        ///  The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            // To customize application configuration such as set high DPI settings or default font,
            // see https://aka.ms/applicationconfiguration.
            ApplicationConfiguration.Initialize();
            Application.Run(new Login());
        }
    }
}
```

### UNO\Properties\Resources.Designer.cs
```cs
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace UNO.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("UNO.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap _19822c18e912ad0ffb2ad2faed8a61af__1__removebg_preview1 {
            get {
                object obj = ResourceManager.GetObject("19822c18e912ad0ffb2ad2faed8a61af__1_-removebg-preview1", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap avatar_removebg_preview {
            get {
                object obj = ResourceManager.GetObject("avatar-removebg-preview", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap clock {
            get {
                object obj = ResourceManager.GetObject("clock", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap clock_removebg_preview {
            get {
                object obj = ResourceManager.GetObject("clock-removebg-preview", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap icon1_removebg_preview {
            get {
                object obj = ResourceManager.GetObject("icon1-removebg-preview", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap images {
            get {
                object obj = ResourceManager.GetObject("images", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap light_blue_settings_gear_22453 {
            get {
                object obj = ResourceManager.GetObject("light-blue-settings-gear-22453", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap light_blue_settings_gear_22453__1_ {
            get {
                object obj = ResourceManager.GetObject("light-blue-settings-gear-22453 (1)", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap login {
            get {
                object obj = ResourceManager.GetObject("login", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap menu {
            get {
                object obj = ResourceManager.GetObject("menu", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap pngtree_uno_card_png_image_9101654 {
            get {
                object obj = ResourceManager.GetObject("pngtree-uno-card-png-image_9101654", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap settings_glyph_black_icon_png_292947_removebg_preview {
            get {
                object obj = ResourceManager.GetObject("settings-glyph-black-icon-png_292947-removebg-preview", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap uno_card_red_poster_fahn507dk0y40lko {
            get {
                object obj = ResourceManager.GetObject("uno-card-red-poster-fahn507dk0y40lko", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
    }
}

```
